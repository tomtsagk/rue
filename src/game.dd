(include "game.ddh")

# -31 -55

# game static states
(def int STATE_IDLE 0)
(def int STATE_DELAY 1)
(def int STATE_INIT 2)
(def int STATE_PLAYCARDS 3)
(def int STATE_REVEALCARDS 4)
(def int STATE_ENDPHASE 5)
(def int STATE_DISCARDTODECK 6)

(def extern ref dd_meshColour newCardMesh)
(def extern ref Card newCard)
(class_function world_game void create (group)
	(group

	# game states
	(= this.stateCurrent STATE_DELAY)
	(= this.stateNext STATE_INIT)
	(= this.stateAnimation 100)
	(= this.stateValue 0)
	(= this.waitingPlayerCard 0)
	(= this.stateText "setting up the table")

	# font
	(this.font.setAlign DD_STRING3D_ALIGN_CENTER)
	(this.font.setColorFront 1.0 1.0 1.0)
	(this.font.setColorBack 0.0 0.0 0.0)

	# camera control
	(= this.rotX 0)
	(= this.rotY 0)
	(= this.targetRotX 0)
	(= this.targetRotY 0)
	(= this.holdRotX -1)
	(= this.holdRotY -1)

	# looking at mesh
	(this.lookat.load (asset "assets/looking_at.asset" DD_PLY))

	# center of world
	(dd_matrix_identity this.matCenter)
	(dd_matrix_translate this.matCenter 0 -4 -5)

	# stage
	(this.stage.load (asset "assets/stage_1.asset" DD_PLY))
	(this.table.load (asset "assets/table_1.asset" DD_PLY))

	# card back
	(this.cardBack.load (asset "assets/card_border.asset" DD_PLY))
	(this.cardBack.loadTexture (asset "assets/card_border_texture.asset" DD_PLY))

	# card cardFront
	(this.cardFront[0].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[0].loadTexture (asset "assets/card_action_2.asset" DD_PLY))

	(this.cardFront[1].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[1].loadTexture (asset "assets/card_action_3.asset" DD_PLY))

	(this.cardFront[2].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[2].loadTexture (asset "assets/card_action_4.asset" DD_PLY))

	(this.cardFront[3].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[3].loadTexture (asset "assets/card_action_5.asset" DD_PLY))

	(this.cardFront[4].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[4].loadTexture (asset "assets/card_action_6.asset" DD_PLY))

	# cards
	(= this.cardsTotal 48)
	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(def int index (dd_math_rand 5))
		(= this.cards[i].mesh this.cardFront[index])
		(= this.cards[i].meshBack this.cardBack)
		(dd_matrix_identity this.cards[i])
		)
	)

	# deck
	(dd_matrix_identity this.deckMatrix)
	(dd_matrix_translate this.deckMatrix -0.5 2 0)
	(dd_matrix_rotate this.deckMatrix 90 1 0 0)
	(dd_matrix_scale this.deckMatrix 0.2 0.2 0.2)
	(= this.deckTotal 0)
	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(this.addToDeck this.cards[i])
		(dd_matrix_copy this.cards[i] this.cards[i].target)
		)
	)

	# discard
	(dd_matrix_identity this.discardMatrix)
	(dd_matrix_translate this.discardMatrix 0.5 2 0)
	(dd_matrix_rotate this.discardMatrix -90 1 0 0)
	(dd_matrix_scale this.discardMatrix 0.2 0.2 0.2)
	(= this.discardTotal 0)

	# players 3-8
	(= this.playersTotal 8)
	(= this.player[0].isUser 1)
	(= this.startingPlayer 0)

	# init player positions
	(for (def int i 1) (< i this.playersTotal) (= i (+ i 1))
		(group
		(dd_matrix_identity this.player[i])
		(dd_matrix_rotate this.player[i] (+ 15 (* (/ 330.0 this.playersTotal) i)) 0 1 0)
		(dd_matrix_translate this.player[i] 0 0 4)

		(if (< i (/ this.playersTotal 2))
			(dd_matrix_rotate this.player[i] 10 0 1 0)
		(> i (/ this.playersTotal 2))
			(dd_matrix_rotate this.player[i] -10 0 1 0)
		)

		(dd_matrix_rotate this.player[i] 180 0 1 0)
		)
	)

	# user's custom matrices
	(dd_matrix_identity this.player[0])
	(dd_matrix_translate this.player[0] 0 0 5)

	(dd_matrix_identity this.player[0].selectedMatrix)
	(dd_matrix_translate this.player[0].selectedMatrix 0 2.01 -3.5)
	(dd_matrix_rotate this.player[0].selectedMatrix 90 1 0 0)
	(dd_matrix_rotate this.player[0].selectedMatrix 180 0 0 1)
	(dd_matrix_scale this.player[0].selectedMatrix 0.15 0.15 0.15)

	# temp rotating card
	(= this.rotating 0)

	)
)

(class_function world_game void onload (group)
	(group
	)
)

#(class_function world_game void resize (group)
#	(group
#	)
#)

(class_function world_game void update (group)
	(group

	# idle state - do nothing
	(if (== this.stateCurrent STATE_IDLE)
		(group)
	# delay for next state
	(== this.stateCurrent STATE_DELAY)
		(group
		(= this.stateAnimation (- this.stateAnimation 1))
		(if (<= this.stateAnimation 0)
			(group
			(= this.stateCurrent this.stateNext)
			(= this.stateAnimation 50)
			)
		)
		)
	# initialise game state - deal cards to players
	(== this.stateCurrent STATE_INIT)
		(group

		# delay before dealing another card
		(if (> this.stateAnimation 0)
			(group
			(= this.stateAnimation (- this.stateAnimation 1))
			)
		# deal one card to the next player
			(group
			(this.drawCard (% this.stateValue this.playersTotal))
			(= this.stateValue (+ this.stateValue 1))
			(= this.stateAnimation 5)

			# dealt all cards
			(if (>= this.stateValue (* this.playersTotal 4))
				(group
				(= this.stateText "playing cards")
				(= this.stateCurrent STATE_DELAY)
				(= this.stateNext STATE_PLAYCARDS)
				(= this.stateAnimation 50)
				(= this.startingPlayer (dd_math_rand this.playersTotal))
				(= this.stateValue this.startingPlayer)
				)
			)

			)
		) # deal cards

		)
	# each player selects one card to play
	(== this.stateCurrent STATE_PLAYCARDS)
		(group

		(if this.waitingPlayerCard
			(group)
		# all players picked cards
		(== this.stateValue (+ this.startingPlayer this.playersTotal))
			(group
			(= this.stateText "revealing cards")
			(= this.stateCurrent STATE_DELAY)
			(= this.stateNext STATE_REVEALCARDS)
			(= this.stateAnimation 50)
			(= this.stateValue this.startingPlayer)
			(= this.stateValue2 0)
			)
		# delay before selecting a card
		(> this.stateAnimation 0)
			(= this.stateAnimation (- this.stateAnimation 1))
		# next player should select a card
			(group

			(def int playerIndex (% this.stateValue this.playersTotal))

			# user has to select a card manually
			(if (== playerIndex 0)
				(group
				(echo "waiting user input")
				(= this.waitingPlayerCard 1)
				)
			# AI will randomly select a card
				(group
				(this.player[playerIndex].selectCard)
				(= this.stateAnimation 50)

				(def int cardIndex this.player[playerIndex].selectedCard)
				(echo "player: " playerIndex " picked card " cardIndex)

				(= this.stateValue (+ this.stateValue 1))

				(def int newIndex (% this.stateValue this.playersTotal))
				(if (== newIndex 0) (= this.stateAnimation 0))

				)
			) # user or AI select a card

			)
		) # check who has to play cards

		)

	# reveal and execute cards
	(== this.stateCurrent STATE_REVEALCARDS)
		(group

		(if
		# waiting to next part
		(> this.stateAnimation 0)
			(group
			(= this.stateAnimation (- this.stateAnimation 1.0))
			)
		# executing card
		(== this.stateValue2 1)
			(group
			(def int playerIndex (% this.stateValue this.playersTotal))
			(echo "executing: " playerIndex)
			(= this.stateValue2 2)
			(= this.stateAnimation 50)
			)
		# hiding card
		(== this.stateValue2 2)
			(group
			(def int playerIndex (% this.stateValue this.playersTotal))

			# put last card in deck
			(this.addToDiscard this.player[playerIndex].selectedCard2)
			(this.player[playerIndex].deselectCard)

			(= this.stateValue2 0)
			(= this.stateValue (+ this.stateValue 1))
			(= this.stateAnimation 50)
			)
		# done executing
		(== this.stateValue (+ this.startingPlayer this.playersTotal))
			(group

			(= this.stateText "end phase")
			(= this.stateCurrent STATE_DELAY)
			(= this.stateNext STATE_ENDPHASE)
			(= this.stateAnimation 50)
			(= this.stateValue this.startingPlayer)

			)
		# reveal next card
			(group

			(def int playerIndex (% this.stateValue this.playersTotal))
			(= this.player[playerIndex].selectedCard2.hidden 0)
			(dd_matrix_rotate this.player[playerIndex].selectedCard2.target 180 0 1 0)
			(= this.stateAnimation 50)
			(= this.stateValue2 1)

			)
		)

		)

	(== this.stateCurrent STATE_ENDPHASE)
		(group
		# waiting to next part
		(if (> this.stateAnimation 0)
			(group
			(= this.stateAnimation (- this.stateAnimation 1.0))
			)
		# done drawing
		(== this.stateValue (+ this.startingPlayer this.playersTotal))
			(group
			(echo "done drawing")
			(= this.stateText "playing cards")
			(= this.stateCurrent STATE_DELAY)
			(= this.stateNext STATE_PLAYCARDS)
			(= this.startingPlayer (dd_math_rand this.playersTotal))
			(= this.stateValue this.startingPlayer)
			)
		# next player draw card
			(group
			(def int playerIndex (% this.stateValue this.playersTotal))
			(this.drawCard playerIndex)

			# draw card succesfull
			(if (== this.stateCurrent STATE_ENDPHASE)
				(group
				(= this.stateAnimation 5)
				(= this.stateValue (+ this.stateValue 1))
				)
			)
			)
		)
		)

	(== this.stateCurrent STATE_DISCARDTODECK)
		(group

		# delay
		(if (> this.stateAnimation 0)
			(group
			(= this.stateAnimation (- this.stateAnimation 1.0))
			)
		# no more discard pile
		(<= this.discardTotal 0)
			(group
			(= this.stateCurrent this.stateNext)
			)
		# pass next card
			(group
			(def int discardIndex (- this.discardTotal 1))
			(this.addToDeck this.discard[discardIndex])
			(= this.discard[discardIndex] 0)
			(= this.discardTotal (- this.discardTotal 1))
			(= this.stateAnimation 5)
			)
		)

		)

	) # states handling

	(= this.rotating (+ this.rotating 1))

	# calculate new camera look at point
	(if (>= this.holdRotX 0)
		(group

		# not rotating yet, check threshold
		(if (== this.isRotating 0)
			(group
			(if (> (dd_math_abs (- (dd_mouse_x) this.holdRotX)) 15)
				(group
				(= this.isRotating 1)
				(= this.holdRotX (dd_mouse_x))
				(= this.holdRotY (dd_mouse_y))
				)
			)
			)
		# is rotating, keep rotating
			(group
			(= this.targetRotX (+ this.targetRotX (* (- (dd_mouse_x) this.holdRotX) 0.25)))
			(= this.targetRotY (- this.targetRotY (* (- (dd_mouse_y) this.holdRotY) 0.25)))
			(= this.holdRotX (dd_mouse_x))
			(= this.holdRotY (dd_mouse_y))
			)
		)
		)
	)

	# slowly approach camera look at point
	(= this.rotX (dd_math_ease_linear 0.1 this.rotX this.targetRotX))
	(= this.rotY (dd_math_ease_linear 0.1 this.rotY this.targetRotY))

	(this.player[0].lookAtCard this.rotX this.rotY)

	#(def float tempRotX this.rotX)
	#(def float tempRotY this.rotY)
	#(echo "rot: " tempRotX " | " tempRotY)

	# update all cards to approach target
	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(dd_matrix_approach this.cards[i] this.cards[i].target 0.1)
		)
	)

	)
) # update

(class_function world_game void draw (group)
	(group

	(dd_matrix_push)

	# camera
	(dd_rotatef this.rotY -1 0 0)
	(dd_rotatef this.rotX 0 1 0)

	# center of world
	(dd_multMatrixf this.matCenter)

	# stage
	(this.stage.draw)
	(this.table.draw)

	# draw deck
	(dd_matrix_push)
	(for (def int i 0) (< i this.deckTotal) (= i (+ i 1))
		(group
		(if this.deck[i]
			(this.deck[i].draw)
		)
		)
	)
	(dd_multMatrixf this.deckMatrix)

	# draw deck number
	(dd_rotatef 180 1 0 0)
	(dd_translatef 0 0 (+ (* 0.01 this.deckTotal) 0.5))
	(dd_rotatef 90 1 0 0)
	(this.font.drawInt this.deckTotal)
	(dd_matrix_pop)

	# draw discard
	(dd_matrix_push)
	(for (def int i 0) (< i this.discardTotal) (= i (+ i 1))
		(group
		(if this.discard[i]
			(this.discard[i].draw)
		)
		)
	)
	(dd_multMatrixf this.discardMatrix)

	# draw discard number
	(dd_translatef 0 0 0.5)
	(dd_rotatef 90 1 0 0)
	(this.font.drawInt this.discardTotal)
	(dd_matrix_pop)

	# draw every player apart from self
	(for (def int i 1) (< i this.playersTotal) (= i (+ i 1))
		(group
		(dd_matrix_push)
		(this.player[i].draw)
		(dd_matrix_pop)
		)
	)

	# draw player
	(dd_matrix_push)
	(this.player[0].draw)
	(dd_matrix_pop)

	# rotating card
#	(dd_translatef 0 3.5 0)
#	(dd_rotatef this.rotating 0 1 0)
#	(dd_scalef 0.5 0.5 0.5)
#	(this.cardBack.draw)
#	(this.cardFront[1].draw)

	(dd_matrix_pop)

	(glClear GL_DEPTH_BUFFER_BIT)

	# states
	(dd_matrix_push)
	(dd_translatef 0 1 -15)
	(this.font.draw this.stateText)
	(dd_matrix_pop)

	(glClear GL_DEPTH_BUFFER_BIT)

	(dd_matrix_push)
	(dd_translatef 0 0 -25)
	(this.lookat.draw)
	(dd_matrix_pop)

	)
)

(class_function world_game void key_input (group char key)
	(group
	(if (== key 27)
		(= dd_flag_exit 1) # exit game
	(== key 101)
		(group
		)
	) # key input
	)
)

(class_function world_game void clean (group)
	(group
	)
)

(class_function world_game void mouse_input (group int button int type)
	(group

	# control the camera look at point when click and dragging
	(if (== type DD_INPUT_MOUSE_TYPE_PRESSED)
		(group
		(= this.holdRotX (dd_mouse_x))
		(= this.holdRotY (dd_mouse_y))
		(= this.isRotating 0)
		)
	(== type DD_INPUT_MOUSE_TYPE_RELEASED)
		(group

		(= this.holdRotX -1)
		(= this.holdRotY -1)

		# was not rotating - click
		(if (== this.isRotating 0)
			(group
			(if (&& this.waitingPlayerCard (>= this.player[0].userLookingAtCard 0))
				(group
				(echo "user manually selected card")
				(this.player[0].selectCard)
				(= this.waitingPlayerCard 0)
				(= this.stateValue (+ this.stateValue 1))
				(= this.stateAnimation 50)
				)
			)
			)
		)

		)
	) # mouse button released

	)
) # mouse input

#
# call it to make a player draw a card from the deck
# `playerIndex` should be the index of that player
#
(class_function world_game void drawCard (group int playerIndex)
	(group

	# if deck is empty, refill it from discard pile
	# this should happen infinitely, and they should
	# never run out
	(if (&& (<= this.deckTotal 0) (> this.discardTotal 0))
		(group
		(= this.stateNext this.stateCurrent)
		(= this.stateCurrent STATE_DISCARDTODECK)
		(= this.stateAnimation 0)
#		(for (def int i 0) (< i this.discardTotal) (= i (+ i 1))
#			(group
#			(this.addToDeck this.discard[i])
#			(= this.discard[i] 0)
#			)
#		)
#		(= this.discardTotal 0)
		)
	# check player index validity (shouldn't happen)
	(|| (< playerIndex 0) (>= playerIndex this.playersTotal))
		(echo "INVALID PLAYER ID")
	# not any cards left in deck
	(<= this.deckTotal 0)
		(group

		# deck is empty, and wasn'y replenished by discard pile
		(echo "CANNOT DRAW MORE CARDS FROM THE DECK, DISCARD ALSO EMPTY")

		)
	# deck has cards to draw from
		(group

		# get top card
		(def int cardIndex (- this.deckTotal 1))

		# player has too many cards already (should never happen)
		(if (== this.player[playerIndex].cardsTotal 10)
			(echo "CANNOT GIVE MORE CARDS, SKIP")
		# player can handle one more card
			(group
			(this.player[playerIndex].addCard this.deck[cardIndex])

			# if card goes to an opponent, hide it
			(if (> playerIndex 0)
				(= this.deck[cardIndex].hidden 1)
			)

			# remove card from deck
			(= this.deck[cardIndex] 0)
			(= this.deckTotal (- this.deckTotal 1))

			)
		) # player has too many cards

		)
	) #deck has cards to draw from

	)
) # draw card

(class_function world_game void addToDiscard (group Card card)
	(group
	(if (>= this.discardTotal 48)
		(echo "Can't add card to discard")
		(group
		(= this.discard[this.discardTotal] card)
		(= this.discardTotal (+ this.discardTotal 1))
		(dd_matrix_copy card.target this.discardMatrix)
		(dd_matrix_translate card.target 0 0 (* 0.01 (+ this.discardTotal 1)))
		)
	)
	)
)

(class_function world_game void addToDeck (group Card card)
	(group
	(if (>= this.deckTotal 48)
		(echo "Can't add card to deck")
		(group
		(= this.deck[this.deckTotal] card)
		(= this.deckTotal (+ this.deckTotal 1))
		(dd_matrix_copy card.target this.deckMatrix)
		(dd_matrix_translate card.target 0 0 (* -0.01 (+ this.deckTotal 1)))
		)
	)
	)
)
