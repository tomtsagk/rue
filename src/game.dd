(include "game.ddh")
(include "menu.ddh")

# public data
(def int numberOfPlayers)
(def int startingPlayer)
(def int playerAi[5])
(def int isMultiplayerGame)
(def int turnCount)
(def int isHost)
(def int networkOffsetindex)

# multiplayer
(class MultiplayerMessageGameTurn 0
	(group
	(def int playerIndex)
	(def int cardIndex)
	)
)

(def int networkTurnIndexMax 15)
(def MultiplayerMessageGameTurn networkTurnQueue[15])
(def int currentNetworkTurnIndex 0)
(def int lastNetworkTurnIndex 0)
(def int networkTurnQueueSize 0)

# game phases
(def int PHASE_INIT 0)
(def int PHASE_PLAN 1)
(def int PHASE_EXECUTION 2)
(def int PHASE_END 3)

# cards
(def int CARD_SINGLE_STEP 0)
(def int CARD_THREE_STEPS 1)
(def int CARD_TRADE 2)
(def int CARD_CONDITIONAL 3)
(def int CARD_REPLACE 4)
(def int CARD_GRAB 5)
(def int CARD_GRAB_GENERIC 6)
(def int CARD_APPROACH 7)
(def int CARD_WIN 8)
(def int CARD_ROSE 9)
(def int CARD_TUT_1 10)
(def int CARD_HOLD_ONE_STEP 17)
(def int CARD_NEXT_HAND 18)
(def int CARD_IGNORE_MOVE 19)
(def int CARD_ROSE_HELD_STEAL 20)
(def int CARD_EMPTY_HEART 21)
(def int CARD_EMPTY_TEAR 22)
(def int CARD_EMPTY_THUNDER 23)
(def int CARD_EMPTY_FROWN 24)

# actions
(def int ACTION_DELAY 0)
(def int ACTION_ADVANCE_ROSE 2)
(def int ACTION_DRAW_CARD 3)
(def int ACTION_SELECT_CARD 4)
(def int ACTION_PLAN_CARD 5)
(def int ACTION_SET_ACTIVE_PLAYER 6)
(def int ACTION_REVEAL_PLANNED_CARD 7)
(def int ACTION_EXECUTE_PLANNED_CARD 8)
(def int ACTION_DISCARD_PLANNED_CARD 9)
(def int ACTION_CHANGE_PHASE 10)
(def int ACTION_GIVE_CARD 11)
(def int ACTION_HIDE_CARD 12)
(def int ACTION_GRAB_ROSE 13)
(def int ACTION_DISCARD_CARD 14)
(def int ACTION_DISCARD_TO_DECK 15)
(def int ACTION_WIN_CONDITION 16)
(def int ACTION_IF_SELECTED_CARD_EQUALS 17)
(def int ACTION_ENDIF 18)
(def int ACTION_IF_SELECTED_CARD_HAS_CORNER 19)
(def int ACTION_SELECT_CARD_CORNER 20)
(def int ACTION_REREVEAL_PLANNED_CARD 21)

(def extern ref dd_meshColour newCardMesh)
(def extern ref Card newCard)
(class_function world_game void create ()
	(group

	(= currentNetworkTurnIndex 0)
	(= lastNetworkTurnIndex 0)
	(= networkTurnQueueSize 0)

	# exit menu buttons
	(= this.buttonTotal 2)
	(this.button[0].mesh.load (asset "assets/button.ply" DD_PLY))
	(this.button[0].label.setText "Exit")

	(this.button[1].mesh.load (asset "assets/button.ply" DD_PLY))
	(this.button[1].label.setText "Resume")

	(this.labelExitMenu.setText "Exit game ?")
	(this.labelExitMenu.setAlign DD_STRING3D_ALIGN_CENTER)

	(this.bgExitMenuTexture.set (asset "assets/bg_exit_menu.png" AVDL_IMAGETYPE_PNG))
	(this.bgExitMenu.set_primitive DD_PRIMITIVE_RECTANGLE)
	(this.bgExitMenu.setTransparency 1)
	(this.bgExitMenu.setTexture this.bgExitMenuTexture)

	(= this.selection 0)
	(= this.selectionClick -1)
	(= this.isExitMenu 0)

	(= turnCount 0)
	(= this.victoriousPlayer -1)
	(= this.msgDelay 0)

	(this.phaseTextSetup.setText "Setting up table ..." )
	(this.phaseTextSetup.setAlign DD_STRING3D_ALIGN_CENTER )
	(this.phaseTextPlanning.setText "Planning Phase" )
	(this.phaseTextPlanning.setAlign DD_STRING3D_ALIGN_CENTER )
	(this.phaseTextExecution.setText "Execution Phase" )
	(this.phaseTextExecution.setAlign DD_STRING3D_ALIGN_CENTER )
	(this.phaseTextEnd.setText "End Phase" )
	(this.phaseTextEnd.setAlign DD_STRING3D_ALIGN_CENTER )
	(this.phaseTextError.setText "Error Phase?" )
	(this.phaseTextError.setAlign DD_STRING3D_ALIGN_CENTER )

	# game phases text
	(= this.phaseText "setting up the table")
	(= this.phaseTextCurrent this.phaseTextSetup)

	# game actions init
	(= this.actionsTotal 0)
	(= this.injectActionsTotal 0)

	# camera control
	(= this.rotX 0)
	(= this.rotY -15)
	(= this.targetRotX 0)
	(= this.targetRotY -15)
	(= this.holdRotX -1)
	(= this.holdRotY -1)

	# looking at mesh
	(this.lookat.load (asset "assets/looking_at.ply" DD_PLY))

	# center of world
	(dd_matrix_identity this.matCenter)
	(if AVDL_VR
		(dd_matrix_translate this.matCenter 0 -3.2 -4)
		(dd_matrix_translate this.matCenter 0 -4 -5)
	)

	# stage
	(= this.isStageColour 1)
	(this.stageCol.load (asset "assets/stage_2.ply" DD_PLY))

	(this.table.load (asset "assets/table_2.ply" DD_PLY))
	(this.tableTexture.set (asset "assets/table_rose.png" AVDL_IMAGETYPE_PNG))
	(this.table.setTexture this.tableTexture)
	(this.tableArrow.load (asset "assets/table_arrow.ply" DD_PLY))
	(this.tableArrowDecoration.load (asset "assets/table_arrow_decoration.ply" DD_PLY))

	# card back
	(this.cardBack.load (asset "assets/card_border.ply" DD_PLY))
	(this.cardBackTexture.set (asset "assets/card_border_texture.png" AVDL_IMAGETYPE_PNG))
	(this.cardBack.setTexture this.cardBackTexture)

	# card cardFront
	(this.cardFront[0].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[0].set (asset "assets/card_01_single_step.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[0].setTexture this.cardFrontTexture[0])

	(this.cardFront[1].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[1].set (asset "assets/card_02_triple_step.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[1].setTexture this.cardFrontTexture[1])

	(this.cardFront[2].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[2].set (asset "assets/card_03_trade.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[2].setTexture this.cardFrontTexture[2])

	(this.cardFront[3].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[3].set (asset "assets/card_04_one_step_cond.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[3].setTexture this.cardFrontTexture[3])

	(this.cardFront[4].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[4].set (asset "assets/card_05_replace.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[4].setTexture this.cardFrontTexture[4])

	(this.cardFront[5].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[5].set (asset "assets/card_06_grab.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[5].setTexture this.cardFrontTexture[5])

	(this.cardFront[6].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[6].set (asset "assets/card_07_grab_gen.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[6].setTexture this.cardFrontTexture[6])

	(this.cardFront[7].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[7].set (asset "assets/card_08_approach.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[7].setTexture this.cardFrontTexture[7])

	(this.cardFront[8].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[8].set (asset "assets/card_09_win.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[8].setTexture this.cardFrontTexture[8])

	(this.cardFront[9].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[9].set (asset "assets/card_tutorial.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[9].setTexture this.cardFrontTexture[9])

	(this.cardFront[10].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[10].set (asset "assets/card_12_ignore_move.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[10].setTexture this.cardFrontTexture[10])

	(this.cardFront[11].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[11].set (asset "assets/card_11_next_hand.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[11].setTexture this.cardFrontTexture[11])

	(this.cardFront[12].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[12].set (asset "assets/card_14_empty.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[12].setTexture this.cardFrontTexture[12])

	(this.cardFront[13].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[13].set (asset "assets/card_10_always_one.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[13].setTexture this.cardFrontTexture[13])

	(this.cardFront[14].load (asset "assets/card.ply" DD_PLY))
	(this.cardFrontTexture[14].set (asset "assets/card_13_steal.png" AVDL_IMAGETYPE_PNG))
	(this.cardFront[14].setTexture this.cardFrontTexture[14])

	(this.cardCorner[0].set_primitive DD_PRIMITIVE_RECTANGLE)
	(this.cardCorner[0].setTransparency 1)
	(this.cardCornerTexture[0].set (asset "assets/card_corner_tear.png" AVDL_IMAGETYPE_PNG))
	(this.cardCorner[0].setTexture this.cardCornerTexture[0])

	(this.cardCorner[1].set_primitive DD_PRIMITIVE_RECTANGLE)
	(this.cardCorner[1].setTransparency 1)
	(this.cardCornerTexture[1].set (asset "assets/card_corner_thunder.png" AVDL_IMAGETYPE_PNG))
	(this.cardCorner[1].setTexture this.cardCornerTexture[1])

	(this.cardCorner[2].set_primitive DD_PRIMITIVE_RECTANGLE)
	(this.cardCorner[2].setTransparency 1)
	(this.cardCornerTexture[2].set (asset "assets/card_corner_frown.png" AVDL_IMAGETYPE_PNG))
	(this.cardCorner[2].setTexture this.cardCornerTexture[2])

	(this.cardCorner[3].set_primitive DD_PRIMITIVE_RECTANGLE)
	(this.cardCorner[3].setTransparency 1)
	(this.cardCornerTexture[3].set (asset "assets/card_corner_heart.png" AVDL_IMAGETYPE_PNG))
	(this.cardCorner[3].setTexture this.cardCornerTexture[3])

	# cards
	(= this.cardsTotal 53)

	(this.prepareDeckFull)

	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(= this.cards[i].hidden 1)
		#(= this.cards[i].font this.cardFont)
		(= this.cards[i].meshBack this.cardBack)
		#(= this.cards[i].cardDescription2 this.cardLabel[2])
		(dd_matrix_identity this.cards[i])
		)
	)

#	# all set debug
#	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
#		(group
#		(this.cards[i].setId CARD_GRAB)
#		(= this.cards[i].mesh this.cardFront[CARD_GRAB])
#		)
#	)

	# tut cards
	(if (this.saveLoad.HadTutorial)
		(= this.guide -1)
		(group
		(if isMultiplayerGame
			(= this.guide -1)
			(= this.guide 0)
		)
		)
	)
	(= this.tutCardsTotal 10)
	(for (def int i 0) (< i this.tutCardsTotal) (= i (+ i 1))
		(group
		(= this.tutCards[i].hidden 0)
		(this.tutCards[i].setId (+ CARD_TUT_1 i))
		(= this.tutCards[i].mesh this.cardFront[9])
		(= this.tutCards[i].meshBack this.cardBack)
		(def int labelIndex (+ 10 i))
		(= this.tutCards[i].cardDescription2 this.cardLabel[labelIndex])

		(def dd_matrix mat)
		(dd_matrix_identity mat)
		(dd_matrix_translate mat -1.75 2.01 2.7)
		(dd_matrix_rotate mat -90 1 0 0)
		(dd_matrix_rotate mat 55 0 0 1)
		(this.tutCards[i].setTarget mat)
		(dd_matrix_copy this.tutCards[i] this.tutCards[i].target)
		(= this.tutCards[i].counter 1)
		)
	)

	# sound effects
	(this.cardLookSound.load (asset "assets/card_look.ogg" DD_PLY))
	(this.cardPlaceSound.load (asset "assets/card_place.ogg" DD_PLY))

	(this.cardSelectSound.load (asset "assets/card_select.ogg" DD_PLY))
	(this.cardDeselectSound.load (asset "assets/card_deselect.ogg" DD_PLY))

	# deck
	(dd_matrix_identity this.deckMatrix)
	(dd_matrix_translate this.deckMatrix -0.40 2 0)
	(dd_matrix_rotate this.deckMatrix 90 1 0 0)
	(= this.deckTotal 0)
	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(this.addToDeck this.cards[i])
		(dd_matrix_copy this.cards[i] this.cards[i].target)
		(= this.cards[i].counter 1)
		)
	)
	(this.shuffleDeck)

	# discard
	(dd_matrix_identity this.discardMatrix)
	(dd_matrix_translate this.discardMatrix 0.40 2 0)
	(dd_matrix_rotate this.discardMatrix -90 1 0 0)
	(= this.discardTotal 0)

	# player meshes
	(this.playerMesh[0].load (asset "assets/character.ply" DD_PLY))
	(this.playerTexture[0].set (asset "assets/character_1.png" AVDL_IMAGETYPE_PNG))
	(this.playerMesh[0].setTexture this.playerTexture[0])
	(this.playerMesh[0].setTransparency 1)

	# players 3-8
	(= this.playersTotal numberOfPlayers)
	(= this.player[0].isUser 1)
	(= this.player[0].mesh this.playerMesh[0])
	(= this.player[0].cardFronts this.cardFront)
	(= this.player[0].cardLabels this.cardLabel)
	(= this.player[0].labelConfirm this.labelConfirm)

	(def int mg isMultiplayerGame)

	# init player positions
	(for (def int i 1) (< i this.playersTotal) (= i (+ i 1))
		(group

		# rotate players kinda towards user
		(def float angle)
		(= angle (+ 0 (* (/ 360.0 this.playersTotal) i)))
		(= angle (/ (- angle 180) 180.0))
		(= angle (* angle 0.9))
		(= angle (+ (* angle 180) 180))
		(dd_matrix_identity this.player[i])
		(dd_matrix_rotate this.player[i] angle 0 -1 0)
		(dd_matrix_translate this.player[i] 0 0 4)

		(def float offset (* -20 (/ (- 180 angle) 180.0)))
		(dd_matrix_rotate this.player[i] offset 0 1 0)

		(dd_matrix_rotate this.player[i] 180 0 1 0)

		# players actual location
		(dd_matrix_identity this.player[i].actual)
		(dd_matrix_rotate this.player[i].actual (- 0 (* (/ 360.0 this.playersTotal) i)) 0 1 0)
		(dd_matrix_translate this.player[i].actual 0 0 4)
		(dd_matrix_rotate this.player[i].actual 180 0 1 0)

		(= this.player[i].cardFronts this.cardFront)
		(if (== playerAi[i] -1)
			(= playerAi[i] 0)
		)
		# network user, random appearance
		(if (== playerAi[i] 10)
			(= this.player[i].mesh this.playerMesh[0])
		# ai, use unique appearance
			(= this.player[i].mesh this.playerMesh[0])
		)
		(= this.player[i].type playerAi[i])

		(= this.player[i].cardLookSound this.cardLookSound)
		(= this.player[i].cardPlaceSound this.cardPlaceSound)

		(= this.player[i].cardSelectSound this.cardSelectSound)
		(= this.player[i].cardDeselectSound this.cardDeselectSound)

		(= this.player[i].labelConfirm this.labelConfirm)

		(= this.player[i].cardLabels this.cardLabel)
		(= this.player[i].isNetworkUser isMultiplayerGame)

		(if (== this.player[i].type 10)
			(this.player[i].font.setText (avdl_multiplayer_getPlayerNameByIndex 0 i))
		)

		)
	)

	# user's custom matrices
	(dd_matrix_identity this.player[0])
	(if AVDL_VR
		(dd_matrix_translate this.player[0] 0 0 4.4)
		(dd_matrix_translate this.player[0] 0 0 5)
	)

	(dd_matrix_identity this.player[0].actual)
	(if AVDL_VR
		(dd_matrix_translate this.player[0].actual 0 0 4.4)
		(dd_matrix_translate this.player[0].actual 0 0 5)
	)

	(dd_matrix_identity this.player[0].selectedMatrix)
	(dd_matrix_translate this.player[0].selectedMatrix 0 2.01 -3.6)
	(dd_matrix_rotate this.player[0].selectedMatrix 90 1 0 0)
	(dd_matrix_rotate this.player[0].selectedMatrix 180 0 0 1)

	(= this.player[0].cardLookSound this.cardLookSound)
	(= this.player[0].cardPlaceSound this.cardPlaceSound)

	(= this.player[0].cardSelectSound this.cardSelectSound)
	(= this.player[0].cardDeselectSound this.cardDeselectSound)

	# temp rotating card
	(= this.rotating 0)

	# rose player
	(= this.isRoseFlat 1)
	(this.roseCardMesh.load (asset "assets/card.ply" DD_PLY))
	(this.roseCardTexture.set (asset "assets/rose.png" AVDL_IMAGETYPE_PNG))
	(this.roseCardMesh.setTexture this.roseCardTexture)
	(this.roseCard.setId CARD_ROSE)
	(= this.roseCard.mesh this.roseCardMesh)
	(= this.roseCard.meshBack this.cardBack)

	# begin the game
	(this.addAction ACTION_CHANGE_PHASE 0 PHASE_INIT 50)

	(this.arrowProgramAvdl.setVertexShader
		(multistring
			"AVDL_IN vec3 colour;\n"
			"AVDL_IN vec2 texCoord;\n"

			"uniform vec3 tint;\n"

			"AVDL_OUT vec2 outTexCoord;\n"
			"AVDL_OUT vec4 outColour;\n"

			"void main() {\n"
			"	vec4 pos = final_position();\n"
			"       gl_Position = pos;\n"
			"       outColour = vec4(colour.rgb *tint.rgb, 1.0);\n"
			"	outTexCoord  = texCoord;\n"
			"}\n"
		)
	)
	(this.arrowProgramAvdl.setFragmentShader
		(multistring
			"AVDL_IN vec4 outColour;\n"
			"AVDL_IN vec2 outTexCoord;\n"

			"uniform sampler2D image;\n"

			"void main() {\n"
			"	avdl_frag_color = outColour +avdl_texture(image, outTexCoord);\n"

			"}\n"
		)
	)

	(= this.arrowActiveCol[0] 0.403)
	(= this.arrowActiveCol[1] 0.698)
	(= this.arrowActiveCol[2] 0.349)

	(= this.arrowInactiveCol[0] 0.694)
	(= this.arrowInactiveCol[1] 0.137)
	(= this.arrowInactiveCol[2] 0.137)

	(= this.arrowCurrentCol[0] 0.0)
	(= this.arrowCurrentCol[1] 0.0)
	(= this.arrowCurrentCol[2] 0.0)

	(= this.arrowRotation 0)
	(= this.arrowRotationTarget 0)

	(this.cardLabel[0].setText "Move The Rose 1 step.")
	(this.cardLabel[0].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[1].setText "Move The Rose 3 steps.")
	(this.cardLabel[1].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[2].setText (multistring
		"Thunder: The Flirt grabs the Rose."
		"Exchange 1 random card with The Flirt. "
		"If a player received The Rose, "
		"they take 1 additional random card. "
	))
	(this.cardLabel[2].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[3].setText (multistring
		"If the player to your right is The Flirt, "
		"move The Rose 1 step."
		"Otherwise "
		"move The Rose 3 steps. "
		"Thunder: The Flirt grabs the Rose."
	))
	(this.cardLabel[3].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[4].setText (multistring
		"Draw one card and "
		"discard this card. "

		"Plan and execute "
		"another card from your hand."
	))
	(this.cardLabel[4].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[5].setText (multistring
		"If you are The Flirt "
		"grab The Rose. Otherwise "
		"move The Rose 1 step and "
		"The Flirt grabs it. "
		"Frown: Move the Rose 1 step."
	))
	(this.cardLabel[5].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[6].setText "The Flirt grabs The Rose. Tear: Move The Rose 1 step.")
	(this.cardLabel[6].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[7].setText (multistring
		"If you are the Flirt, "
		"move The Rose 3 steps. "
		"Otherwise "
		"move The Rose 1 step. "
		"Heart: The Flirt grabs The Rose. "
	))
	(this.cardLabel[7].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[8].setText (multistring
		"If you are holding "
		"The Rose, "
		"discard 1 card. "

		"Move The Rose 1 step."
	))
	(this.cardLabel[8].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[9].setText (multistring
		"A beautiful red rose that smells amazing."
	))
	(this.cardLabel[9].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[10].setText (multistring
		"At start every player draws 5 cards. "
		"One player gets the Rose card in front of them. "
		"Whoever has the Rose is known as the Flirt."
	))
	(this.cardLabel[10].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[11].setText (multistring
		"In the planning phase, starting with the Flirt, "
		"every player picks a card and plans it face down on the table."
	))
	(this.cardLabel[11].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[12].setText (multistring
		"The rose always moves clockwise. "
		"If a player holds the rose moving it one step will "
		"make it move in front of that player."
	))
	(this.cardLabel[12].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[13].setText (multistring
		"In the execution phase starting with the Flirt,"
		"reveal each card and execute its effect."
	))
	(this.cardLabel[13].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[14].setText (multistring
		"In the end phase every player draws one card except the "
		"Flirt. If a player has 2 or less cards in their hand "
		"they win."
	))
	(this.cardLabel[14].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[15].setText (multistring
		"The first enemy will only play a card to move the Rose 1 step."
	))
	(this.cardLabel[15].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[16].setText (multistring
		"The second enemy will only play a card to move the Rose 3 steps."
	))
	(this.cardLabel[16].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[17].setText (multistring
		"If The Flirt is holding The Rose, move it 2 steps. "
		"Otherwise, move the Rose 1 step."
	))
	(this.cardLabel[17].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[18].setText (multistring
		"If The Flirt is holding The Rose, move it 2 steps "
		"and The Flirt now grabs The Rose. "
		"Frown: Move The Rose 1 step."
	))
	(this.cardLabel[18].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[19].setText (multistring
		"Ignore the effect of the next card. "
		"Move the Rose 1 step. "
		"Heart: Move the Rose 1 step."
	))
	(this.cardLabel[19].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[20].setText (multistring
		"Tear: The Flirt grabs The Rose."
		"Select 1 random card from "
		"The Flirt's hand. If it was The Rose, "
		"move it 2 steps."
	))
	(this.cardLabel[20].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[21].setText (multistring
		"Heart: The Flirt grabs The Rose."
	))
	(this.cardLabel[21].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[22].setText (multistring
		"Tear: The Flirt grabs The Rose."
	))
	(this.cardLabel[22].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[23].setText (multistring
		"Thunder: The Flirt grabs The Rose."
	))
	(this.cardLabel[23].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.cardLabel[24].setText (multistring
		"Frown: The Flirt grabs The Rose."
	))
	(this.cardLabel[24].setAlign DD_STRING3D_ALIGN_CENTER)

	(this.labelWin.setText "You won! Click anywhere to continue.")
	(this.labelWin.setAlign DD_STRING3D_ALIGN_CENTER)
	(this.labelLose.setText "You lost! Click anywhere to continue.")
	(this.labelLose.setAlign DD_STRING3D_ALIGN_CENTER)

	(this.labelConfirm.setText "Confirm?")
	(this.labelConfirm.setAlign DD_STRING3D_ALIGN_CENTER)

	(this.phaseTextCornerEffectOrSkip.setText "Discard card to activate extra effect or skip.")
	(this.phaseTextCornerEffectOrSkip.setAlign DD_STRING3D_ALIGN_CENTER)

	(= this.filterCorner -1)

	(this.font.setAlign DD_STRING3D_ALIGN_CENTER)

	(this.buttonProgram.setVertexShader
		(multistring
			"AVDL_IN vec3 colour;\n"
			"AVDL_IN vec2 texCoord;\n"

			"uniform vec3 tint;\n"

			"AVDL_OUT vec2 outTexCoord;\n"
			"AVDL_OUT vec4 outColour;\n"

			"void main() {\n"
			"	vec4 pos = final_position();\n"
			"       gl_Position = pos;\n"
			"       outColour = vec4(colour.rgb *tint.rgb, 1.0);\n"
			"	outTexCoord  = texCoord;\n"
			"}\n"
		)
	)
	(this.buttonProgram.setFragmentShader
		(multistring
			"AVDL_IN vec4 outColour;\n"
			"AVDL_IN vec2 outTexCoord;\n"

			"uniform sampler2D image;\n"

			"void main() {\n"
			"	avdl_frag_color = outColour +avdl_texture(image, outTexCoord);\n"
			"}\n"
		)
	)

	(= this.buttonClickCol[0] 0.389)
	(= this.buttonClickCol[1] 0.055)
	(= this.buttonClickCol[2] 0.682)

	(= this.buttonActiveCol[0] 0.916)
	(= this.buttonActiveCol[1] 0.516)
	(= this.buttonActiveCol[2] 0.074)

	(= this.buttonInactiveCol[0] 0.694)
	(= this.buttonInactiveCol[1] 0.137)
	(= this.buttonInactiveCol[2] 0.137)

	(this.lookatMesh.load (asset "assets/eye.ply" DD_PLY))

	)
)

(class_function world_game void onload ()
	(group
	(this.theme.load (asset "assets/game_theme.ogg" DD_PLY))
	(this.theme.playLoop -1)
	)
)

(class_function world_game void resize ()
	(group
	# portrait
	(if (< (dd_window_width) (dd_window_height))
		(group
		# exit button
		(this.button[0].setSize 1 1)
		(this.button[0].setProportionalPosition 0.5 0.25)
		(this.button[0].setProportionalWidth 0.2)
		(this.button[0].setProportionalSize 0.8)

		# resume button
		(this.button[1].setSize 1 1)
		(this.button[1].setProportionalPosition 0.5 0.5)
		(this.button[1].setProportionalWidth 0.2)
		(this.button[1].setProportionalSize 0.8)
		)
	# landscape
		(group
		# exit button
		(this.button[0].setSize 1 1)
		(this.button[0].setProportionalPosition 0.7 0.3)
		(this.button[0].setProportionalWidth 0.2)
		(this.button[0].setProportionalSize 0.8)

		# resume button
		(this.button[1].setSize 1 1)
		(this.button[1].setProportionalPosition 0.3 0.3)
		(this.button[1].setProportionalWidth 0.2)
		(this.button[1].setProportionalSize 0.8)
		)
	)
	(for (def int i 0) (< i this.buttonTotal) (= i (+ i 1))
		(this.button[i].resize)
	)
	)
)

(class_function world_game void update (group float dt)
	(group

	# currently displaying a card, handle that instead of game state
	(if (== AVDL_VR 0)
		(if this.ovButtons.cardToShow
			(this.ovButtons.lookAt this.rotX this.rotY)
		)
	)

	# execute remaining actions
	(if (&& (> this.actionsTotal 0) (|| (== this.ovButtons.cardToShow 0) (== this.ovButtons.waitUntilCardConfirmed 0)))
		(group

		# delay after executing an action
		(if (== this.actions[0].actionType ACTION_DELAY)
			(group
			(if (> this.actions[0].delay 0)
				(= this.actions[0].delay (- this.actions[0].delay (* 70 dt)))
				(this.removeAction)
			)
			)
		# change phases
		(== this.actions[0].actionType ACTION_CHANGE_PHASE)
			(group

			# initialise phase
			(if (== this.actions[0].value PHASE_INIT)
				(group
				(= this.phaseText "initialising game")

				# decide starting player
				(if (== startingPlayer -1)
					(= startingPlayer (dd_math_rand this.playersTotal))
				)
				(this.setRosePlayer startingPlayer)
				(dd_matrix_copy this.roseCard this.roseCard.target)
				(= this.roseCard.counter 1)

				# all players draw starting cards
				(for (def int j 0) (< j 5) (= j (+ j 1))
				(for (def int i 0) (< i this.playersTotal) (= i (+ i 1))
					(this.addAction ACTION_DRAW_CARD (% (+ i startingPlayer) this.playersTotal) 0 5)
				)
				)

				# start with planning phase
				(this.addAction ACTION_CHANGE_PHASE 0 PHASE_PLAN 50)

				# guide
				(if (== this.guide 0)
					(group
					(this.ovButtons.setCard this.tutCards[0])
					(= this.guide (+ this.guide 1))
					)
				)
				#(this.ovButtons.setCard this.deck[0])

				)
			# planning phase
			(== this.actions[0].value PHASE_PLAN)
				(group
				(= this.phaseText "planning phase")
				(= this.phaseTextCurrent this.phaseTextPlanning)

				# ask all players to plan a card
				(for (def int i this.rosePlayer) (< i (+ this.playersTotal this.rosePlayer)) (= i (+ i 1))
					(group
					(def int index (% i this.playersTotal))
					(this.addAction ACTION_SET_ACTIVE_PLAYER index 0 20)
					(this.addAction ACTION_SELECT_CARD index index 0)
					(this.addAction ACTION_PLAN_CARD -1 0 50)
					)
				)

				# when done, move to execution phase
				(this.addAction ACTION_CHANGE_PHASE 0 PHASE_EXECUTION 50)

				(if (== this.guide 1)
					(group
					(this.ovButtons.setCard this.tutCards[1])
					(= this.guide (+ this.guide 1))
					)
				)

				)
			# execution phase
			(== this.actions[0].value PHASE_EXECUTION)
				(group
				(= this.phaseText "execution phase")
				(= this.phaseTextCurrent this.phaseTextExecution)

				# reveal all planned cards, and execute their actions
				(for (def int i this.rosePlayer) (< i (+ this.playersTotal this.rosePlayer)) (= i (+ i 1))
					(group
					(def int index (% i this.playersTotal))
					(this.addAction ACTION_SET_ACTIVE_PLAYER index 0 20)
					(this.addAction ACTION_REVEAL_PLANNED_CARD index 0 50)
					(this.addAction ACTION_EXECUTE_PLANNED_CARD index 0 50)
					(this.addAction ACTION_DISCARD_PLANNED_CARD index 0 50)
					)
				)

				# when done, move to end phase
				(this.addAction ACTION_CHANGE_PHASE 0 PHASE_END 50)

				(if (== this.guide 3)
					(group
					(this.ovButtons.setCard this.tutCards[3])
					(= this.guide (+ this.guide 1))
					)
				)

				)
			# end phase
			(== this.actions[0].value PHASE_END)
				(group
				(= this.phaseText "end phase")
				(= this.phaseTextCurrent this.phaseTextEnd)

				# all players, apart from the rose player, draw a card
				(for (def int i (+ this.rosePlayer 1)) (< i (+ this.playersTotal this.rosePlayer)) (= i (+ i 1))
					(group
					(def int index (% i this.playersTotal))
					(this.addAction ACTION_DRAW_CARD index 0 5)
					)
				)

				# if held, flat rose
				(if (== this.isRoseFlat 0)
					(this.addAction ACTION_ADVANCE_ROSE 0 1 5)
				)

				# check for victory condition
				(this.addAction ACTION_WIN_CONDITION 0 0 0)

				# when done, restart planning phase
				(this.addAction ACTION_CHANGE_PHASE 0 PHASE_PLAN 50)

				(if (== this.guide 4)
					(group
					(this.ovButtons.setCard this.tutCards[4])
					(= this.guide (+ this.guide 1))
					)
				)

				)
			# error phase (should never trigger)
				(group
				(= this.phaseText "error phase")
				(= this.phaseTextCurrent this.phaseTextError)
				)
			)

			(= this.actions[0].actionType ACTION_DELAY)

			)
		# advance rose to next player
		(== this.actions[0].actionType ACTION_ADVANCE_ROSE)
			(group

			# rose is held by someone, flat it and lose one movement
			(if (== this.isRoseFlat 0)
				(group

				(= this.isRoseFlat 1)
				(= this.actions[0].value (- this.actions[0].value 1))

				# find the rose
				(def int roseIndex -1)
				(for (def int i 0) (< i this.player[this.rosePlayer].cardsTotal) (= i (+ i 1))
					(group
					(if (== this.player[this.rosePlayer].cards[i].id CARD_ROSE)
						(group
						(= roseIndex i)
						(= i 100)
						)
					)
					)
				)

				# should never happen
				(if (== roseIndex -1)
					(echo "rose is not held by rose player ?")
				# flat the rose
					(group
					(this.player[this.rosePlayer].removeCard roseIndex)
					(this.setRosePlayer this.rosePlayer)
					)
				)

				)
			)

			# there is movement left, move the rose
			(if (> this.actions[0].value 0)
				(group
				(this.setRosePlayer (% (+ this.rosePlayer this.actions[0].value) this.playersTotal))
				)
			)

			(= this.actions[0].actionType ACTION_DELAY)

			)
		# draw card
		(== this.actions[0].actionType ACTION_DRAW_CARD)
			(group
			(this.drawCard this.actions[0].playerIndex)
			(= this.actions[0].actionType ACTION_DELAY)
			)
		# select a card
		(== this.actions[0].actionType ACTION_SELECT_CARD)
			(group

			# invalid player has to select a card? (shouldn't happen)
			(if (|| (< this.actions[0].playerIndex 0) (>= this.actions[0].playerIndex this.playersTotal))
				(echo "invalid player cannot select a card")
			# user has to select a card from their own hands
			(&& (== this.actions[0].playerIndex 0) (== this.actions[0].value this.actions[0].playerIndex))
				(group

				# player has to select card of given corner filter
				(if (>= this.filterCorner 0)
					(group

					# check if player has cards with such corner
					(def int hasCard 0)
					(for (def int i 0) (< i this.player[this.actions[0].playerIndex].cardsTotal) (= i (+ i 1))
						(group
						(if (== this.player[this.actions[0].playerIndex].cards[i].cornerId this.filterCorner)
							(group
							(= hasCard 1)
							(= i this.player[this.actions[0].playerIndex].cardsTotal)
							)
						)
						)
					)

					# has cards with corner to play - wait for player to choose one
					(if hasCard
						()
					# doesn't have card with corner - skip selecting a card
					# for now user must manually skipped effect
						(group
						#(= this.actions[0].actionType ACTION_DELAY)
						#(= this.actions[0].delay 0)
						#(= this.filterCorner -1)
						#(= this.lastSelectedCardPlayerIndex -1)
						#(= this.lastSelectedCardIndex -1)
						#(this.ovButtons.unsetCard)
						)
					)

					)
				)

				(if (== this.guide 2)
					(group
					(this.ovButtons.setCard this.tutCards[2])
					(= this.guide (+ this.guide 1))
					)
				)
				)
			# network user selects card from themselves, wait for their input
			(&& (== this.player[this.actions[0].playerIndex].type 10) (== this.actions[0].value this.actions[0].playerIndex))
				(group

				# there's a move waiting to happen
				(if (> networkTurnQueueSize 0)
					(group
					# update the state of the game based on the received move
					#(= this.lastSelectedCardPlayerIndex (% (- (+ msg.playerIndex this.playersTotal) networkOffsetindex) this.playersTotal))
					(= this.lastSelectedCardPlayerIndex (% (- (+ networkTurnQueue[currentNetworkTurnIndex].playerIndex this.playersTotal) networkOffsetindex) this.playersTotal))
					#(= this.lastSelectedCardIndex msg.cardIndex)
					(= this.lastSelectedCardIndex networkTurnQueue[currentNetworkTurnIndex].cardIndex)
#					(def int pind this.lastSelectedCardPlayerIndex)
#					(def int cind this.lastSelectedCardIndex)
#					(echo "player card index received: " pind " | " cind)
					(= this.filterCorner -1)
					(this.ovButtons.unsetCard)
					(= this.actions[0].actionType ACTION_DELAY)
					(= this.actions[0].delay 0)

					#(= this.player[0].userLookingAtCard -1)
					#(= this.player[0].highlightCard -1)
					(= this.phaseTextCurrent this.phaseTextExecution)

					(= currentNetworkTurnIndex (+ currentNetworkTurnIndex 1))
					(= networkTurnQueueSize (- networkTurnQueueSize 1))
					(if (>= currentNetworkTurnIndex networkTurnIndexMax)
						(= currentNetworkTurnIndex (- currentNetworkTurnIndex networkTurnIndexMax))
					)
					(echo "applied queued move")
					)
					(group
					(echo "waiting network user to have a turn")
					)
				)

				)
			# AI has to select a card or user selects randomly or network user selects randomly
				(group

				# corner filter is active
				(if (>= this.filterCorner 0)
					(group

					# network game - host makes ai decision and sends it
					# to other players
					(if isMultiplayerGame
						(group

						(if isHost
							(group

							# find number of available cards
							(def int cornerCards 0)
							(for (def int i 0) (< i this.player[this.actions[0].playerIndex].cardsTotal) (= i (+ i 1))
								(if (== this.player[this.actions[0].playerIndex].cards[i].cornerId this.filterCorner)
									(= cornerCards (+ cornerCards 1))
								)
							)

							# has cards with corner to play - pick one randomly
							(if cornerCards
								(group
								(= this.lastSelectedCardPlayerIndex this.actions[0].value)
								(= this.lastSelectedCardIndex (dd_math_rand cornerCards))
								(for (def int i 0) (< i this.player[this.actions[0].playerIndex].cardsTotal) (= i (+ i 1))
									(if (== this.player[this.actions[0].playerIndex].cards[i].cornerId this.filterCorner)
										(group
										(= cornerCards (- cornerCards 1))
										(if (<= cornerCards 0)
											(= this.lastSelectedCardIndex i)
										)
										)
									)
								)
								)
							# doesn't have card with corner - skip selecting a card
								(group
								(= this.lastSelectedCardPlayerIndex -1)
								(= this.lastSelectedCardIndex -1)
								)
							)
							(= this.filterCorner -1)
							(this.ovButtons.unsetCard)

							(echo "sending ai corner move to all players")
							(def MultiplayerMessageGameTurn msg)
							(= msg.playerIndex this.lastSelectedCardPlayerIndex)
							(= msg.cardIndex this.lastSelectedCardIndex)
							(avdl_multiplayer_sendMessage 0 msg MultiplayerMessageGameTurn)

							)
						# non-host users wait for host to
						# send ai moves
							(group
							)
						)

						)
					# not network game - continue as normal
						(group

						# find number of available cards
						(def int cornerCards 0)
						(for (def int i 0) (< i this.player[this.actions[0].playerIndex].cardsTotal) (= i (+ i 1))
							(if (== this.player[this.actions[0].playerIndex].cards[i].cornerId this.filterCorner)
								(= cornerCards (+ cornerCards 1))
							)
						)

						# has cards with corner to play - pick one randomly
						(if cornerCards
							(group
							(= this.lastSelectedCardPlayerIndex this.actions[0].value)
							(= this.lastSelectedCardIndex (dd_math_rand cornerCards))
							(for (def int i 0) (< i this.player[this.actions[0].playerIndex].cardsTotal) (= i (+ i 1))
								(if (== this.player[this.actions[0].playerIndex].cards[i].cornerId this.filterCorner)
									(group
									(= cornerCards (- cornerCards 1))
									(if (<= cornerCards 0)
										(= this.lastSelectedCardIndex i)
									)
									)
								)
							)
							)
						# doesn't have card with corner - skip selecting a card
							(group
							(= this.lastSelectedCardPlayerIndex -1)
							(= this.lastSelectedCardIndex -1)
							)
						)
						(= this.filterCorner -1)
						(this.ovButtons.unsetCard)

						)
					)

					)
				# no corner filter - pick randomly
					(group

					# network game
					(if isMultiplayerGame
						(group

						# host allows ai to make decisions and
						# sends moves to other users
						(if isHost
							(group
							(= this.lastSelectedCardPlayerIndex this.actions[0].value)
							(= this.lastSelectedCardIndex (dd_math_rand this.player[this.lastSelectedCardPlayerIndex].cardsTotal))
							(= this.filterCorner -1)
							(this.ovButtons.unsetCard)

							(def MultiplayerMessageGameTurn msg)
							(= msg.playerIndex this.lastSelectedCardPlayerIndex)
							(= msg.cardIndex this.lastSelectedCardIndex)

							(echo "sending ai move to all players")
							(avdl_multiplayer_sendMessage 0 msg MultiplayerMessageGameTurn)

							)
						# non-host users wait for host to
						# send ai moves
							(group
							)
						)

						)
					# not network game - make ai decision
						(group
						(= this.lastSelectedCardPlayerIndex this.actions[0].value)
						(= this.lastSelectedCardIndex (dd_math_rand this.player[this.lastSelectedCardPlayerIndex].cardsTotal))
						(= this.filterCorner -1)
						(this.ovButtons.unsetCard)
						)
					)

					)
				)
				(= this.actions[0].actionType ACTION_DELAY)

				)
			)

			)
		# select a card with a specific corner
		(== this.actions[0].actionType ACTION_SELECT_CARD_CORNER)
			(group

			(if (== this.actions[0].playerIndex 0)
				(= this.phaseTextCurrent this.phaseTextCornerEffectOrSkip)
			)

			(= this.filterCorner this.actions[0].value)
			(= this.actions[0].value this.actions[0].playerIndex)
			(= this.actions[0].actionType ACTION_SELECT_CARD)

			)
		# plan card
		(== this.actions[0].actionType ACTION_PLAN_CARD)
			(group

			# player index is given as -1, use last selected card/player combo
			(if (== this.actions[0].playerIndex -1)
				(group

				(if (|| (== this.lastSelectedCardPlayerIndex -1) (== this.lastSelectedCardIndex -1))
					(echo "tried to plan unselected card!")
				# player tried to plan the rose! blasphemy! select another card
				(== this.player[this.lastSelectedCardPlayerIndex].cards[this.lastSelectedCardIndex].id CARD_ROSE)
					(group
					(this.addInjectAction ACTION_SELECT_CARD this.lastSelectedCardPlayerIndex this.lastSelectedCardPlayerIndex 0)
					(this.addInjectAction ACTION_PLAN_CARD -1 0 50)
					(this.injectActionsToActions)
					)
				# player tried to plan the "replace" card, while being last, select another card
				(&&
					(== this.player[this.lastSelectedCardPlayerIndex].cards[this.lastSelectedCardIndex].id CARD_REPLACE)
					(== (% (+ this.rosePlayer this.playersTotal -1) this.playersTotal) this.lastSelectedCardPlayerIndex)
				)
					(group
					(this.addInjectAction ACTION_SELECT_CARD this.lastSelectedCardPlayerIndex this.lastSelectedCardPlayerIndex 0)
					(this.addInjectAction ACTION_PLAN_CARD -1 0 50)
					(this.injectActionsToActions)
					)
				# selected card can be planned, so plan it
					(this.player[this.lastSelectedCardPlayerIndex].planCard this.lastSelectedCardIndex)
				)

				)
			# player and card index are given, use those instead
				(group
				(this.player[this.actions[0].playerIndex].planCard this.actions[0].value)
				)
			)

			(= this.actions[0].actionType ACTION_DELAY)
			)
		# set active player
		(== this.actions[0].actionType ACTION_SET_ACTIVE_PLAYER)
			(group
			(this.applyArrowRotation this.actions[0].playerIndex)
			(= this.actions[0].actionType ACTION_DELAY)
			)
		# reveal planned card
		(== this.actions[0].actionType ACTION_REVEAL_PLANNED_CARD)
			(group
			(def int playerIndex this.actions[0].playerIndex)
			(= this.ovButtons.waitUntilCardConfirmed 1)

			# there is a planned card - reveal it
			(if (this.player[playerIndex].hasPlannedCard)
				(group
				(= this.player[playerIndex].selectedCard2.hidden 0)

				(def dd_matrix mat)
				(dd_matrix_copy mat this.player[playerIndex].selectedCard2.target)
				(dd_matrix_rotate mat 180 0 1 0)
				(this.player[playerIndex].selectedCard2.setTarget mat)

				(this.ovButtons.setCard this.player[playerIndex].selectedCard2)
				)
			# no planned card - skip this action
				(group
				(= this.actions[0].delay 0)
				)
			)
			(= this.actions[0].actionType ACTION_DELAY)
			)
		# re-reveal planned card
		(== this.actions[0].actionType ACTION_REREVEAL_PLANNED_CARD)
			(group
			(def int playerIndex this.actions[0].playerIndex)

			# there is a planned card - reveal it
			(if (this.player[playerIndex].hasPlannedCard)
				(group
				# for user - don't wait for user input
				(if (== playerIndex 0)
					(= this.ovButtons.waitUntilCardConfirmed 0)
				# for AI or network user - wait user to confirm action
					(= this.ovButtons.waitUntilCardConfirmed 1)
				)
				(this.ovButtons.setCard this.player[playerIndex].selectedCard2)
				)
			# no planned card - skip this action
				(group
				(= this.actions[0].delay 0)
				)
			)
			(= this.actions[0].actionType ACTION_DELAY)
			)
		# execute planned card
		(== this.actions[0].actionType ACTION_EXECUTE_PLANNED_CARD)
			(group

			(def int playerIndex this.actions[0].playerIndex)

			# there is a planned card - execute it
			(if (this.player[playerIndex].hasPlannedCard)
				(group

				# based on the card being executed, inject it's actions in the stack
				(def int cardId this.player[this.actions[0].playerIndex].selectedCard2.id)
				(def int cornerId this.player[this.actions[0].playerIndex].selectedCard2.cornerId)

				# move rose one step
				(if (== cardId CARD_SINGLE_STEP)
					(group
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)

#					# example of corner effect
#					#(this.addInjectAction ACTION_REVEAL_PLANNED_CARD this.actions[0].playerIndex 0 50)
#					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
#					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_TEAR 50)
#					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_TEAR 0)
#					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
#					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
#					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 1 50)
#					(this.addInjectAction ACTION_ENDIF 0 0 0)

					(this.injectActionsToActions)
					)
				# move rose three steps
				(== cardId CARD_THREE_STEPS)
					(group
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
					(this.injectActionsToActions)
					)
				# trade - give 1 card to rose player, take 1 card back
				(== cardId CARD_TRADE)
					(group

					# corner ability
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_THUNDER 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_THUNDER 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)

					# the active player is the flirt - nothing happens
					(if (== this.rosePlayer this.actions[0].playerIndex)
						(group
						)
					# the active player is NOT the flirt - continue with effect
						(group

						# active player selects (randomly) and gives a card to rose player
						(this.addInjectAction ACTION_SELECT_CARD this.rosePlayer this.actions[0].playerIndex 0)
						(this.addInjectAction ACTION_GIVE_CARD this.rosePlayer 0 50)

						# rose player selects and gives a card to active player
						# TODO: should be given a card at random, rose player doesn't select
						(this.addInjectAction ACTION_SELECT_CARD this.actions[0].playerIndex this.rosePlayer 0)

						# if rose was selected, take an additional card
						(this.addInjectAction ACTION_IF_SELECTED_CARD_EQUALS 0 CARD_ROSE 0)
						(this.addInjectAction ACTION_GIVE_CARD this.actions[0].playerIndex 0 50)
						(this.addInjectAction ACTION_SELECT_CARD this.actions[0].playerIndex this.rosePlayer 0)
						(this.addInjectAction ACTION_ENDIF 0 0 0)

						(this.addInjectAction ACTION_GIVE_CARD this.actions[0].playerIndex 0 50)

						)
					)

					(this.injectActionsToActions)

					)
				# if previous player is the flirt, move Rose one step, otherwise three steps
				(== cardId CARD_CONDITIONAL)
					(group
					(def int onePreviousIndex (% (- (+ this.actions[0].playerIndex this.playersTotal) 1) this.playersTotal))
					(if (== onePreviousIndex this.rosePlayer)
						(group
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
						)
					# else
						(group
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
						)
					)

					# corner ability
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_THUNDER 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_THUNDER 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)

					)
				# discard your planned card, draw one card, plan another card and execute it
				(== cardId CARD_REPLACE)
					(group
					(this.addInjectAction ACTION_DISCARD_PLANNED_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_SELECT_CARD this.actions[0].playerIndex this.actions[0].playerIndex 0)
					(this.addInjectAction ACTION_PLAN_CARD -1 0 50)
					(this.addInjectAction ACTION_REVEAL_PLANNED_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_EXECUTE_PLANNED_CARD this.actions[0].playerIndex 0 50)
					(this.injectActionsToActions)
					)
				# grab
				# If rose is in front of you, grab it, otherwise move rose 1 step.
				#	The new rose player grabs the rose.
				(== cardId CARD_GRAB)
					(group

					# rose is in front of user, grab it
					(if (== this.actions[0].playerIndex this.rosePlayer)
						(group
						(if (== this.actions[0].playerIndex 0)
							(avdl_achievements_set 0 "ACHIEVEMENT_I_FOUND_THE_ROSE")
						)
						(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
						)
					# otherwise, move one step, rose player grabs rose
						(group
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
						(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
						)
					)

					# corner ability
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_FROWN 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_FROWN 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)

					)
				# grab generic
				# If rose is flat, the player in front of it grabs it.
				(== cardId CARD_GRAB_GENERIC)
					(group

					(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)

					# corner ability
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_TEAR 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_TEAR 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)

					)
				# aproach
				# If you are not the rose player, move rose 1 step, otherwise move it 3 steps.
				(== cardId CARD_APPROACH)
					(group

					# active user is rose player, move rose 3 steps
					(if (== this.actions[0].playerIndex this.rosePlayer)
						(group
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
						)
					# active user is not rose player, move rose 1 step
						(group
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
						)
					)

					# corner ability
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_HEART 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_HEART 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)

					)
				# win
				# If you are holding the rose, discard 1 card. Move rose 1 step.
				(== cardId CARD_WIN)
					(group

					# holding the rose, discard 1 card
					(if (&& (== this.actions[0].playerIndex this.rosePlayer) (== this.isRoseFlat 0))
						(group
						(this.addInjectAction ACTION_SELECT_CARD this.actions[0].playerIndex this.actions[0].playerIndex 50)
						(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
						(if (== this.actions[0].playerIndex 0)
							(avdl_achievements_set 0 "ACHIEVEMENT_EXTRA_DISCARD")
						)
						)
					)

					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
					(this.injectActionsToActions)

					)
				# hold one step
				# If rose is held, move two steps, otherwise move one step
				(== cardId CARD_HOLD_ONE_STEP)
					(group

					(if (== this.isRoseFlat 0)
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
					)

					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)

					(this.injectActionsToActions)

					)
				# next hand
				# If rose is held, move to next player's hand
				(== cardId CARD_NEXT_HAND)
					(group

					(if (== this.isRoseFlat 0)
						(group
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
						(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 20)
						(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
						)
					)

					# corner ability
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_FROWN 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_FROWN 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)

					)
				# ignore next
				# ignore the next player's planned card
				(== cardId CARD_IGNORE_MOVE)
					(group

					# if next player has a card, discard it
					(def int nextIndex (% (+ (+ this.actions[0].playerIndex this.playersTotal) 1) this.playersTotal))
					(if (this.player[nextIndex].hasPlannedCard)
						(group
						(def dd_matrix mat)
						(dd_matrix_copy mat this.player[nextIndex].selectedCard2.target)
						(dd_matrix_rotate mat 180 0 1 0)
						(this.player[nextIndex].selectedCard2.setTarget mat)
						(= this.player[nextIndex].selectedCard2.hidden 0)
						(this.addInjectAction ACTION_DISCARD_PLANNED_CARD nextIndex 0 50)
						)
					)
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)

					# corner ability
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_HEART 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_HEART 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)

					)
				# rose held steal
				# if rose is held, reveal a random card from flirt, if rose move two steps
				(== cardId CARD_ROSE_HELD_STEAL)
					(group

					# corner ability
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_TEAR 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_TEAR 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)

					# if selected card is rose, move two steps
					(this.addInjectAction ACTION_SELECT_CARD this.actions[0].playerIndex this.rosePlayer 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_EQUALS 0 CARD_ROSE 0)
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
					(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)

					(this.injectActionsToActions)

					)
				# empty
				# if special card in hand, flirt grabs rose
				(== cardId CARD_EMPTY_TEAR)
					(group
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_TEAR 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_TEAR 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)
					)
				(== cardId CARD_EMPTY_HEART)
					(group
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_HEART 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_HEART 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)
					)
				(== cardId CARD_EMPTY_THUNDER)
					(group
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_THUNDER 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_THUNDER 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)
					)
				(== cardId CARD_EMPTY_FROWN)
					(group
					(this.addInjectAction ACTION_REREVEAL_PLANNED_CARD this.actions[0].playerIndex 0 0)
					(this.addInjectAction ACTION_SELECT_CARD_CORNER this.actions[0].playerIndex CARD_CORNER_FROWN 50)
					(this.addInjectAction ACTION_IF_SELECTED_CARD_HAS_CORNER 0 CARD_CORNER_FROWN 0)
					(this.addInjectAction ACTION_DISCARD_CARD -1 0 50)
					(this.addInjectAction ACTION_GRAB_ROSE 0 0 50)
					(this.addInjectAction ACTION_DRAW_CARD this.actions[0].playerIndex 0 50)
					(this.addInjectAction ACTION_ENDIF 0 0 0)
					(this.injectActionsToActions)
					)
				)
				)
			# no planned card - skip this action
				(group
				(= this.actions[0].delay 0)
				)
			)

			(= this.actions[0].actionType ACTION_DELAY)
			)
		# discard planned card
		(== this.actions[0].actionType ACTION_DISCARD_PLANNED_CARD)
			(group
			(def int playerIndex this.actions[0].playerIndex)

			# there is a planned card - discard it
			(if (this.player[playerIndex].hasPlannedCard)
				(group
				(this.addToDiscard this.player[playerIndex].selectedCard2)
				(this.player[playerIndex].deselectCard)
				)
			# no planned card - skip this action
				(group
				(= this.actions[0].delay 0)
				)
			)

			(= this.actions[0].actionType ACTION_DELAY)

			)
		# give card to another player
		(== this.actions[0].actionType ACTION_GIVE_CARD)
			(group

			(def int receiverIndex this.actions[0].playerIndex)

			# user is receiving a card, reveal it straight away
			(if (== receiverIndex 0)
				(= this.player[this.lastSelectedCardPlayerIndex].cards[this.lastSelectedCardIndex].hidden 0)
			)

			# rose is being given
			(if (== this.player[this.lastSelectedCardPlayerIndex].cards[this.lastSelectedCardIndex].id CARD_ROSE)
				(= this.rosePlayer receiverIndex)
			# user is giving a non-rose card, mark it to become hidden when arriving at opponent
			(== this.lastSelectedCardPlayerIndex 0)
				(group
				(this.addInjectAction ACTION_HIDE_CARD receiverIndex this.player[receiverIndex].cardsTotal 0)
				(this.injectActionsToActions)
				)
			)

			(this.player[receiverIndex].addCard this.player[this.lastSelectedCardPlayerIndex].cards[this.lastSelectedCardIndex])
			(this.player[this.lastSelectedCardPlayerIndex].removeCard this.lastSelectedCardIndex)
			(= this.actions[0].actionType ACTION_DELAY)

			)

		# hide given card
		(== this.actions[0].actionType ACTION_HIDE_CARD)
			(group
			(= this.player[this.actions[0].playerIndex].cards[this.actions[0].value].hidden 1)
			(= this.actions[0].actionType ACTION_DELAY)
			)

		# the rose player, grabs the rose
		(== this.actions[0].actionType ACTION_GRAB_ROSE)
			(group

			(if this.isRoseFlat
				(this.grabRose)
			)

			(= this.actions[0].actionType ACTION_DELAY)

			)

		# discard card from player's hand
		(== this.actions[0].actionType ACTION_DISCARD_CARD)
			(group

			(def int playerIndex)
			(def int cardIndex)
			# discard previously selected card
			(if (== this.actions[0].playerIndex -1)
				(group
				(= playerIndex this.lastSelectedCardPlayerIndex)
				(= cardIndex this.lastSelectedCardIndex)
				)
			# discard given card
				(group
				(= playerIndex this.actions[0].playerIndex)
				(= cardIndex this.actions[0].value)
				)
			)

			# attempting to discard rose, flat it instead
			(if (== this.player[playerIndex].cards[cardIndex].id CARD_ROSE)
				(group
				(this.addInjectAction ACTION_ADVANCE_ROSE 0 1 50)
				(this.injectActionsToActions)
				)
			# discard selected card
				(group
				(= this.player[playerIndex].cards[cardIndex].hidden 0)
				(this.addToDiscard this.player[playerIndex].cards[cardIndex])
				(this.player[playerIndex].removeCard cardIndex)
				)
			)

			(= this.actions[0].actionType ACTION_DELAY)

			)

		# put discard pile to deck
		(== this.actions[0].actionType ACTION_DISCARD_TO_DECK)
			(group

			# there are still discarded cards
			(if (> this.discardTotal 0)
				(group

				# delay between each card
				(= this.actions[0].value (- this.actions[0].value 1))

				# put next discarded card to deck
				(if (<= this.actions[0].value 0)
					(group
					(def int disIndex (- this.discardTotal 1))
					(this.addToDeck this.discard[disIndex])
					(= this.discard[disIndex] 0)
					(= this.discardTotal (- this.discardTotal 1))
					(= this.actions[0].value this.actions[0].delay)
					)
				)
				)
			# no cards left in discard pile - move to next part
				(group
				(this.shuffleDeck)
				(= this.actions[0].actionType ACTION_DELAY)
				)
			)

			) # discard pile to deck

		# win condition
		(== this.actions[0].actionType ACTION_WIN_CONDITION)
			(group

			(if (< this.victoriousPlayer 0)
				(group
				(def int winningPlayer -1)

				# a player with 2 cards or less is the winner
				# tie-breaker is whoever is closest to the rose player
				(for (def int i this.rosePlayer) (< i (+ this.rosePlayer this.playersTotal)) (= i (+ i 1))
					(group

					(def int index (% i this.playersTotal))

					# player won
					(if (<= this.player[index].cardsTotal 2)
						(group
						(= winningPlayer index)
						(= i 100)
						)
					)

					)
				)

				# someone won
				(if (>= winningPlayer 0)
					(group
					(= this.victoriousPlayer winningPlayer)

				(this.saveLoad.CompleteGame)
					# Handle achievements
					(if (&& (== this.victoriousPlayer 0) (== (this.saveLoad.GetGamesComplete) 1))
						(avdl_achievements_set 0 "ACHIEVEMENT_FIRST_VICTORY")
					(&& (== this.victoriousPlayer 0) (== (this.saveLoad.GetGamesComplete) 3))
						(avdl_achievements_set 0 "ACHIEVEMENT_GETTING_BETTER")
					(&& (== this.victoriousPlayer 0) (== (this.saveLoad.GetGamesComplete) 7))
						(avdl_achievements_set 0 "ACHIEVEMENT_MASTER_PLAYER")
					)
					)
				# nobody won
					(group
					(= this.actions[0].actionType ACTION_DELAY)
					)
				)
				)
			)

			)
		(== this.actions[0].actionType ACTION_IF_SELECTED_CARD_EQUALS)
			(group
			# no card is selected - skip to end of if statement
			(if (|| (== this.lastSelectedCardPlayerIndex -1) (== this.lastSelectedCardIndex -1))
				(group
				(for (def int i 0) (&& (|| (< this.actions[0].actionType ACTION_ENDIF) (> this.actions[0].actionType ACTION_ENDIF)) (> this.actionsTotal 0)) (= i i)
					(this.removeAction)
				)
				)
			# desired card is selected - continue as normal
			(== (this.player[this.lastSelectedCardPlayerIndex].cards[this.lastSelectedCardIndex].getId) this.actions[0].value)
				(group
				(if (== this.actions[0].playerIndex 0)
					(avdl_achievements_set 0 "ACHIEVEMENT_ROSE_SELECTED")
				)
				)
			# not wanted card is selected - skip to end of if statement
				(group
				(for (def int i 0) (&& (|| (< this.actions[0].actionType ACTION_ENDIF) (> this.actions[0].actionType ACTION_ENDIF)) (> this.actionsTotal 0)) (= i i)
					(this.removeAction)
				)
				)
			)
			(= this.actions[0].actionType ACTION_DELAY)
			)
		(== this.actions[0].actionType ACTION_IF_SELECTED_CARD_HAS_CORNER)
			(group
			# no card is selected - skip to end of if statement
			(if (|| (== this.lastSelectedCardPlayerIndex -1) (== this.lastSelectedCardIndex -1))
				(group
				(for (def int i 0) (&& (|| (< this.actions[0].actionType ACTION_ENDIF) (> this.actions[0].actionType ACTION_ENDIF)) (> this.actionsTotal 0)) (= i i)
					(this.removeAction)
				)
				)
			# desired corner is selected - continue as normal
			(== this.player[this.lastSelectedCardPlayerIndex].cards[this.lastSelectedCardIndex].cornerId this.actions[0].value)
				()
			# not wanted card is selected - skip to end of if statement
				(group
				(for (def int i 0) (&& (|| (< this.actions[0].actionType ACTION_ENDIF) (> this.actions[0].actionType ACTION_ENDIF)) (> this.actionsTotal 0)) (= i i)
					(this.removeAction)
				)
				)
			)
			(= this.actions[0].actionType ACTION_DELAY)
			)
		(== this.actions[0].actionType ACTION_ENDIF)
			(group
			(= this.actions[0].actionType ACTION_DELAY)
			)

		) # different behavior for each action

		)
	)

	(= this.rotating (+ this.rotating (* 0.25 dt)))

	# calculate new camera look at point
	(if (&& (>= this.holdRotX 0) (== AVDL_VR 0))
		(group

		# not rotating yet, check threshold
		(if (== this.isRotating 0)
			(group
			(if (|| (> (dd_math_abs (- (dd_mouse_x) this.holdRotX)) 15)
			        (> (dd_math_abs (- (dd_mouse_y) this.holdRotY)) 15))
				(group
				(= this.isRotating 1)
				(= this.holdRotX (dd_mouse_x))
				(= this.holdRotY (dd_mouse_y))
				)
			)
			)
		# is rotating, keep rotating
			(group
			(= this.targetRotX
				(dd_math_max
					(dd_math_min
						(+ this.targetRotX (* (- (dd_mouse_x) this.holdRotX) 0.25))
						100
					)
					-100
				)
			)
			(= this.targetRotY
				(dd_math_max
					(dd_math_min
						(- this.targetRotY (* (- (dd_mouse_y) this.holdRotY) 0.25))
						70
					)
					-65
				)
			)
			(= this.holdRotX (dd_mouse_x))
			(= this.holdRotY (dd_mouse_y))
			)
		)
		)
	)

	#(if this.waitingPlayerCard
	(if (== AVDL_VR 0)
		(group
		# slowly approach camera look at point
		(= this.rotX (dd_math_ease_linear (* 2.0 dt) this.rotX this.targetRotX))
		(= this.rotY (dd_math_ease_linear (* 2.0 dt) this.rotY this.targetRotY))

		(this.player[0].lookAtCard this.rotX this.rotY)
		)
	)

	# update all cards to approach target
	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(this.cards[i].update dt)
		)
	)
	(this.roseCard.update dt)
	(for (def int i 0) (< i this.tutCardsTotal) (= i (+ i 1))
		(this.tutCards[i].update (* dt 1.2))
	)

	# update table arrow
	(= this.arrowRotation (dd_math_ease_linear (* 2.5 dt) this.arrowRotation this.arrowRotationTarget))

	# user is about to play a card
	(if (&& (> this.actionsTotal 0) (== this.actions[0].actionType ACTION_SELECT_CARD) (== this.actions[0].playerIndex 0))
		(group
		(= this.arrowCurrentCol[0] (dd_math_ease_linear (* 2.5 dt) this.arrowCurrentCol[0] this.arrowActiveCol[0] ))
		(= this.arrowCurrentCol[1] (dd_math_ease_linear (* 2.5 dt) this.arrowCurrentCol[1] this.arrowActiveCol[1] ))
		(= this.arrowCurrentCol[2] (dd_math_ease_linear (* 2.5 dt) this.arrowCurrentCol[2] this.arrowActiveCol[2] ))
		)
		(group
		(= this.arrowCurrentCol[0] (dd_math_ease_linear (* 2.5 dt) this.arrowCurrentCol[0] this.arrowInactiveCol[0] ))
		(= this.arrowCurrentCol[1] (dd_math_ease_linear (* 2.5 dt) this.arrowCurrentCol[1] this.arrowInactiveCol[1] ))
		(= this.arrowCurrentCol[2] (dd_math_ease_linear (* 2.5 dt) this.arrowCurrentCol[2] this.arrowInactiveCol[2] ))
		)
	)

	(this.ovButtons.update)

	(if isMultiplayerGame
		(group
		(= this.msgDelay (+ this.msgDelay 1))
		(if (> this.msgDelay 100)
			(group

			# received a move from a network player
			(if (avdl_multiplayer_receiveMessages 0)
				(group
				(echo "got message, checking magic word")

				(def ref MultiplayerMessageGameTurn msg)
				(= msg (avdl_multiplayer_getMessageData 0))

#				# host sends the move to all other players
#				# except the one that just made the move
#				(if (avdl_multiplayer_isHost 0)
#					(group
#					#(avdl_multiplayer_syncMessage 0 msg MultiplayerMessageGameTurn)
#					)
#				)

				(if (>= networkTurnQueueSize networkTurnIndexMax)
					(group
					(echo "no space for more network turns!")
					)
					(group
					# queue move
					(= networkTurnQueue[lastNetworkTurnIndex].playerIndex msg.playerIndex)
					(= networkTurnQueue[lastNetworkTurnIndex].cardIndex msg.cardIndex)
					(= lastNetworkTurnIndex (+ lastNetworkTurnIndex 1))
					(= networkTurnQueueSize (+ networkTurnQueueSize 1))
					(if (>= lastNetworkTurnIndex networkTurnIndexMax)
						(= lastNetworkTurnIndex (- lastNetworkTurnIndex networkTurnIndexMax))
					)
					(echo "queued network move")
					)
				)

#				# update the state of the game based on the received move
#				(= this.lastSelectedCardPlayerIndex (% (- (+ msg.playerIndex this.playersTotal) networkOffsetindex) this.playersTotal))
#				#(= this.lastSelectedCardIndex this.player[(+ msg.playerIndex networkOffsetindex)].highlightCard)
#				(= this.lastSelectedCardIndex msg.cardIndex)
#				(def int pind this.lastSelectedCardPlayerIndex)
#				(def int cind this.lastSelectedCardIndex)
#				(echo "player card index received: " pind " | " cind)
#				(= this.filterCorner -1)
#				(this.ovButtons.unsetCard)
#				(= this.actions[0].actionType ACTION_DELAY)
#				(= this.actions[0].delay 0)
#
#				#(= this.player[0].userLookingAtCard -1)
#				#(= this.player[0].highlightCard -1)
#				(= this.phaseTextCurrent this.phaseTextExecution)
#				(echo "received move, and applied it")
				)
				(echo "no messages")
			)

			(= this.msgDelay 0)
			)
		)
		)
	)

	# check if mouse is hovering over a button
	(for (def int i 0) (< i this.buttonTotal) (= i (+ i 1))
		(group

		(if (== this.selection i)
			(group
			)
			(if (this.button[i].hasMouseCollided)
				(group
				#(this.hoverSound.play)
				(= this.selection i)
				)
			)
		)

		(this.button[i].update dt (== this.selection i) (== this.selectionClick i))

		)
	)

	# on systems with visible controllers (quest 2 for now)
	(if (dd_matrix_hasVisibleControllers)
		(for (def int i 1) (< i 2) (= i (+ i 1))
			(group
			(if (dd_matrix_isControllerVisible i)
				(group
				(this.ovButtons.lookAtPhysical (dd_matrix_getControllerPosition i))
				(this.player[0].lookAtCardPos (dd_matrix_getControllerPosition i))
				)
			)
			)
		)
	)

	# on systems with visible controllers (quest 2 for now)
	(if (&& (dd_matrix_hasVisibleControllers) this.isExitMenu)
		(for (def int i 1) (< i 2) (= i (+ i 1))
			(group
			(if (dd_matrix_isControllerVisible i)
				(group
				# check if mouse is hovering over a button
				(for (def int j 0) (< j this.buttonTotal) (= j (+ j 1))
					(group

					(if (== this.selection j)
						(group
						)
						(if (this.button[j].hasPositionCollided (dd_matrix_getControllerPosition i))
							(group
							#(this.hoverSound.play)
							(= this.selection j)
							)
						)
					)

					(this.button[j].update dt (== this.selection j) (== this.selectionClick j))

					)
				)
				)
			)
			)
		)
	)

	)
) # update

(class_function world_game void draw ()
	(group

	(dd_matrix_push)

	# camera
	(if (== AVDL_VR 0)
		(group
		(dd_rotatef this.rotY -1 0 0)
		(dd_rotatef this.rotX 0 1 0)
		)
	)

	# center of world
	(dd_multMatrixf this.matCenter)

	# stage
	(if this.isStageColour
		(this.stageCol.draw)
		(this.stage.draw)
	)
	(this.table.draw)
	(dd_matrix_push)
	(dd_rotatef this.arrowRotation 0 1 0)
	(this.arrowProgramAvdl.useProgram)
	(def int colLoc)
	(= colLoc (avdl_getUniformLocation this.arrowProgramAvdl "tint"))
	(avdl_graphics_SetUniform3f colLoc this.arrowCurrentCol[0] this.arrowCurrentCol[1] this.arrowCurrentCol[2])
	(this.tableArrow.draw)
	(avdl_useProgram 0)
	(this.tableArrowDecoration.draw)
	(dd_matrix_pop)

	# draw deck
	(dd_matrix_push)
	(for (def int i 0) (< i this.deckTotal) (= i (+ i 1))
		(group
		(if this.deck[i]
			(this.deck[i].draw)
		)
		)
	)

	# draw tut cards
	(for (def int i 0) (< i this.tutCardsTotal) (= i (+ i 1))
		(group
		(this.tutCards[i].draw)
		)
	)

	# rose is flat, draw it
	# if rose is held, player will draw it
	(if this.isRoseFlat
		(this.roseCard.draw)
	)

	(dd_multMatrixf this.deckMatrix)

	# draw deck number
	(dd_rotatef 180 1 0 0)
	(dd_translatef 0 0 (+ (* 0.003 this.deckTotal) 0.12))
	(dd_rotatef 90 1 0 0)
	(dd_scalef 0.20 0.20 0.20)
	(this.font.drawInt this.deckTotal)
	(dd_matrix_pop)

	# draw discard
	(dd_matrix_push)
	(for (def int i 0) (< i this.discardTotal) (= i (+ i 1))
		(group
		(if this.discard[i]
			(this.discard[i].draw)
		)
		)
	)
	(dd_multMatrixf this.discardMatrix)

	# draw discard number
	(dd_translatef 0 0 (+ (* 0.003 this.discardTotal) 0.12))
	(dd_rotatef 90 1 0 0)
	(dd_scalef 0.2 0.2 0.2)
	(this.font.drawInt this.discardTotal)
	(dd_matrix_pop)

	# draw every player apart from self
	(for (def int i 1) (< i this.playersTotal) (= i (+ i 1))
		(group
		(dd_matrix_push)
		(this.player[i].draw)
		(dd_translatef 0 0 -5 )
		(this.labelPlayerName.setText (avdl_multiplayer_getPlayerNameByIndex 0 0))
		(dd_matrix_pop)
		)
	)

	# draw player
	(dd_matrix_push)
	(this.player[0].draw)
	(dd_matrix_pop)

	(if this.ovButtons.cardToShow
		(this.ovButtons.draw)
	)

	# rotating card
	#(dd_translatef 0 3.5 0)
	#(dd_rotatef this.rotating 0 1 0)
	#(dd_scalef 5.0 5.0 5.0)
	#(this.deck[32].drawRaw)
	#(this.tutCards[0].drawRaw)
	#(this.cardBack.draw)
	#(this.cardFront[1].draw)

	(dd_matrix_pop)

	(if (== AVDL_VR 0)
		(avdl_graphics_ClearDepth)
	)

	# states
	(if (== this.isExitMenu 0)
		(group
		(dd_matrix_push)
		(if AVDL_VR
			(group
			(dd_translatef 0 1.5 -3)
			(dd_scalef 0.2 0.2 0.2)
			)
			(group
			(dd_translatef 0 (* (dd_screen_height_get 20) 0.4) -20)
			)
		)
		# draw end game
		(if (>= this.victoriousPlayer 0)
			(group
			(if (== this.victoriousPlayer 0)
				(this.labelWin.drawLimit
					(* (dd_screen_width_get 20) 2 0.8)
				)
				(this.labelLose.drawLimit
					(* (dd_screen_width_get 20) 2 0.8)
				)
			)
			)
		# draw text of overlay card
		this.ovButtons.isLookingAtCard
			(if this.ovButtons.cardToShow.cardDescription2
				(group
				(this.ovButtons.cardToShow.cardDescription2.drawLimit
					(* (dd_screen_width_get 20) 2 0.8)
				)
				)
			)
		# player looking card
		(>= this.player[0].userLookingAtCard 0)
			(if this.player[0].cards[this.player[0].userLookingAtCard].cardDescription2
				(group
				(this.player[0].cards[this.player[0].userLookingAtCard].cardDescription2.drawLimit
					(* (dd_screen_width_get 20) 2 0.8)
				)
				)
			)
		# draw phase
			(group
			(this.phaseTextCurrent.drawLimit
				(* (dd_screen_width_get 20) 2 0.8)
			)
			)
		)
		(dd_matrix_pop)
		)
	)

	# clear depth
	(if (== AVDL_VR 0)
		(group
		(avdl_graphics_ClearDepth)

		# lookat mesh
		(dd_matrix_push)
		(dd_translatef 0 0 -25)
		(this.lookat.draw)
		(dd_matrix_pop)

		)
	)

	(this.player[0].drawLookingAtText)

	(if this.isExitMenu
		(group

		(avdl_graphics_ClearDepth)

		# bg
		(dd_matrix_push)
		(if AVDL_VR
			(group
			(dd_translatef 0 0 -5)
			(dd_scalef (dd_screen_width_get 5) (dd_screen_height_get 5) 0)
			)
			(group
			(dd_translatef 0 0 -15)
			(dd_scalef (dd_screen_width_get 15) (dd_screen_height_get 15) 0)
			)
		)
		(this.bgExitMenu.draw)
		(dd_matrix_pop)

		(if (== AVDL_VR 0)
			(avdl_graphics_ClearDepth)
		)

		(dd_matrix_push)
		(if AVDL_VR
			(group
			(dd_translatef 0 3 -4.8)
			(this.labelExitMenu.drawLimit
				(* (dd_screen_width_get 4.8) 2 0.8)
			)
			)
			(group
			(dd_translatef 0 3 -15)
			(this.labelExitMenu.drawLimit
				(* (dd_screen_width_get 20) 2 0.8)
			)
			)
		)
		(dd_matrix_pop)

		# draw buttons
		(this.buttonProgram.useProgram)
		(= colLoc (avdl_getUniformLocation this.buttonProgram "tint"))
		(for (def int i 0) (< i this.buttonTotal) (= i (+ i 1))
			(group
			(dd_matrix_push)

			# change the shader colour when clicked
			(if (> this.button[i].idleCol 1.0)
				(avdl_graphics_SetUniform3f colLoc
					(dd_math_ease_linear
						(- this.button[i].idleCol 1.0)
						this.buttonActiveCol[0] this.buttonClickCol[0]
					)
					(dd_math_ease_linear
						(- this.button[i].idleCol 1.0)
						this.buttonActiveCol[1] this.buttonClickCol[1]
					)
					(dd_math_ease_linear
						(- this.button[i].idleCol 1.0)
						this.buttonActiveCol[2] this.buttonClickCol[2]
					)
				)
			# change colour when selected
				(avdl_graphics_SetUniform3f colLoc
					(dd_math_ease_linear this.button[i].idleCol this.buttonInactiveCol[0] this.buttonActiveCol[0])
					(dd_math_ease_linear this.button[i].idleCol this.buttonInactiveCol[1] this.buttonActiveCol[1])
					(dd_math_ease_linear this.button[i].idleCol this.buttonInactiveCol[2] this.buttonActiveCol[2])
				)
			)

			(this.button[i].applyTransform)
			(this.button[i].applyMatrixTransform)
			(def float anim)
			# big numbers make animation faster, but blends less together (max 4 - number of buttons)
			# small numbers make animation slower. At 1.0, all buttons animate together
			(def float animationSpeed 2.0)
			(def float animationSpeedMult (- 1.0 (/ 1.0 animationSpeed)))
			(= anim (dd_math_min
					(dd_math_max
						1
						#(* (- this.animationOpen (* (/ animationSpeedMult (- this.buttonTotal 1)) i)) animationSpeed)
						0
					)
					1
				)
			)
			(dd_scalef anim anim anim)
			(this.button[i].drawRaw)

			(dd_translatef 0 0 0.1)
			(dd_scalef 0.3 0.3 0.3)

			(this.button[i].drawText)

			(dd_matrix_pop)
			)
		)
		(avdl_useProgram 0)

		)
	)

	# on systems with visible controllers (quest 2 for now)
	(if (dd_matrix_hasVisibleControllers)
		(for (def int i 0) (< i 2) (= i (+ i 1))
			(group
			(if (dd_matrix_isControllerVisible i)
				(group
				(dd_matrix_push)
				(dd_matrix_applyControllerMatrix i)
				(dd_rotatef 180 0 1 0)
				(dd_scalef 0.05 0.05 0.05)
				(this.lookatMesh.draw)
				(dd_matrix_pop)
				)
			)
			)
		)
	)

	)
)

(class_function world_game void key_input (group int key)
	(group

	# escape button / back
	(if (||
		(&& (== AVDL_VR 0) (== key 27))
		(&& (== AVDL_VR 1) (== key AVDL_INPUT_QUEST2_MENU))
		)
		(group
		#(= dd_flag_exit 1) # exit game
		#(dd_world_prepare world_menu 1.0)
		#(dd_world_ready)
		(if this.isExitMenu
			(group
			(dd_world_prepare world_menu 1.0)
			(dd_world_ready)
			)
			(= this.isExitMenu 1)
		)
		)
	# left arrow or 'a'
	(|| (== key 1) (== key 97))
		(group

		# exit menu navigation
		(if this.isExitMenu
			(group
			# portrait
			(if (< (dd_window_width) (dd_window_height))
				(group
				)
			# landscape
				(group
				(= this.selection 1)
				)
			)
			)
		# not in exit menu - control camera
			(= this.targetRotX (- this.targetRotX 10))
		)

		)
	# right arrow or 'd'
	(|| (== key 3) (== key 100))
		(group

		# exit menu navigation
		(if this.isExitMenu
			(group
			# portrait
			(if (< (dd_window_width) (dd_window_height))
				(group
				)
			# landscape
				(group
				(= this.selection 0)
				)
			)
			)
		# not in exit menu - control camera
			(= this.targetRotX (+ this.targetRotX 10))
		)

		)
	# up arrow or 'w'
	(|| (== key 2) (== key 119))
		(group

		# exit menu navigation
		(if this.isExitMenu
			(group
			# portrait
			(if (< (dd_window_width) (dd_window_height))
				(group
				(= this.selection 1)
				)
			# landscape
				(group
				)
			)
			)
		# not in exit menu - control camera
			(= this.targetRotY (+ this.targetRotY 10))
		)

		)
	# down arrow or 's'
	(|| (== key 4) (== key 115))
		(group

		# exit menu navigation
		(if this.isExitMenu
			(group
			# portrait
			(if (< (dd_window_width) (dd_window_height))
				(group
				(= this.selection 0)
				)
			# landscape
				(group
				)
			)
			)
		# not in exit menu - control camera
			(= this.targetRotY (- this.targetRotY 10))
		)

		)
	# enter or space to confirm
	(|| (== key 13) (== key 32) (== key AVDL_INPUT_QUEST2_TRIGGER_R))
		(group

		# exit menu navigation
		(if this.isExitMenu
			(group
			# exit game
			(if (== this.selection 0)
				(group
				(dd_world_prepare world_menu 1.0)
				(dd_world_ready)
				)
			# resume
			(== this.selection 1)
				(group
				(= this.isExitMenu 0)
				)
			)
			)
			(group
			(this.confirmSelection)
			)
		)

		)
	) # key input

	)
)

(class_function world_game void clean ()
	(group
	(this.theme.stop)
	)
)

(class_function world_game void mouse_input (group int button int type)
	(group

	# re-check selection, this allows the user to directly click on a button
	# in a touch screen device
	(for (def int i 0) (< i this.buttonTotal) (= i (+ i 1))
		(group

		(if (this.button[i].hasMouseCollided)
			(group
			(= this.selection i)
			)
		)

		)
	)

	# pass input to exit menu
	(if this.isExitMenu
		(group
		(if (== type DD_INPUT_MOUSE_TYPE_PRESSED)
			(group
			(if (&& (>= this.selection 0) (this.button[this.selection].hasMouseCollided))
				(= this.selectionClick this.selection)
			)
			)
		(== type DD_INPUT_MOUSE_TYPE_RELEASED)
			(group
			(if (&& (== this.selection this.selectionClick)
				(>= this.selection 0) (this.button[this.selection].hasMouseCollided))
				(group
				# exit game
				(if (== this.selectionClick 0)
					(group
					(dd_world_prepare world_menu 1.0)
					(dd_world_ready)
					)
				# resume
				(== this.selectionClick 1)
					(group
					(= this.isExitMenu 0)
					)
				)
				)
			)
			(= this.selectionClick -1)
			)
		)
		(return)
		)
	)

	# control the camera look at point when click and dragging
	(if (== type DD_INPUT_MOUSE_TYPE_PRESSED)
		(group
		(= this.holdRotX (dd_mouse_x))
		(= this.holdRotY (dd_mouse_y))
		(= this.isRotating 0)
		)
	(== type DD_INPUT_MOUSE_TYPE_RELEASED)
		(group

		(= this.holdRotX -1)
		(= this.holdRotY -1)

		# was not rotating - click
		(if (== this.isRotating 0)
			(group
			(this.confirmSelection)
			)
		)

		)
	) # mouse button released

	)
) # mouse input

#
# call it to make a player draw a card from the deck
# `playerIndex` should be the index of that player
#
(class_function world_game void drawCard (group int playerIndex)
	(group

	# if deck is empty, refill it from discard pile
	# this should happen infinitely, and they should
	# never run out
	(if (&& (<= this.deckTotal 0) (> this.discardTotal 0))
		(group

		# add discard to deck
		# draw 1 card, same player
		(this.addInjectAction ACTION_DISCARD_TO_DECK 0 0 10)
		(this.addInjectAction ACTION_DRAW_CARD playerIndex 0 5)
		(this.injectActionsToActions)

		)
	# check player index validity (shouldn't happen)
	(|| (< playerIndex 0) (>= playerIndex this.playersTotal))
		(echo "INVALID PLAYER ID")
	# not any cards left in deck
	(<= this.deckTotal 0)
		(group

		# deck is empty, and wasn't replenished by discard pile
		(echo "CANNOT DRAW MORE CARDS FROM THE DECK, DISCARD ALSO EMPTY")

		)
	# deck has cards to draw from
		(group

		# get top card
		(def int cardIndex (- this.deckTotal 1))

		# player has too many cards already (should never happen)
		(if (== this.player[playerIndex].cardsTotal 10)
			(echo "CANNOT GIVE MORE CARDS, SKIP")
		# player can handle one more card
			(group

			(this.deck[cardIndex].clearFakeId)
			(this.player[playerIndex].addCard this.deck[cardIndex])

			# if card goes to an opponent, hide it
			(if (> playerIndex 0)
				(= this.deck[cardIndex].hidden 1)
				(= this.deck[cardIndex].hidden 0)
			)

			# remove card from deck
			(= this.deck[cardIndex] 0)
			(= this.deckTotal (- this.deckTotal 1))

			)
		) # player has too many cards

		)
	) #deck has cards to draw from

	)
) # draw card

(class_function world_game void addToDiscard (group Card card)
	(group

	# check limits, should never happen
	(if (>= this.discardTotal this.cardsTotal)
		(echo "Can't add card to discard")
	# add card to discard pile
		(group
		(= this.discard[this.discardTotal] card)
		(= this.discardTotal (+ this.discardTotal 1))
		(def dd_matrix mat)
		(dd_matrix_copy mat this.discardMatrix)
		(dd_matrix_translate mat 0 0 (+ (* 0.003 (+ this.discardTotal 1)) 0.01))
		(card.setTarget card mat)
		)
	)
	)
)

(class_function world_game void addToDeck (group Card card)
	(group

	# check limits, should never happen
	(if (>= this.deckTotal this.cardsTotal)
		(echo "Can't add card to deck")
	# add card to deck
		(group
		(= this.deck[this.deckTotal] card)
		(= this.deckTotal (+ this.deckTotal 1))
		(def dd_matrix mat)
		(dd_matrix_copy mat this.deckMatrix)
		(dd_matrix_translate mat 0 0 (+ (* -0.003 (+ this.deckTotal 1)) -0.01))
		(card.setTarget card mat)
		)
	)
	)
)

(class_function world_game void setRosePlayer (group int playerId)
	(group

	# check playerId sanity
	(if (|| (< playerId 0) (>= playerId this.playersTotal))
		(echo "invalid player id")
	# special functionality for user
	(== playerId 0)
		(group
		(= this.rosePlayer playerId)
		(def dd_matrix mat)
		(dd_matrix_identity mat)
		(dd_matrix_translate mat 0 2.01 2.1)
		(dd_matrix_rotate mat -90 1 0 0)
		(this.roseCard.setTarget mat)
		)
	# position rose in front of another player
		(group
		(= this.rosePlayer playerId)
		(def dd_matrix mat)
		(dd_matrix_identity mat)
		(dd_matrix_mult mat this.player[playerId].actual)
		(dd_matrix_translate mat 0 2.01 1.9)
		(dd_matrix_rotate mat -90 1 0 0)
		(dd_matrix_rotate mat 180 0 0 1)
		(this.roseCard.setTarget mat)
		)
	)

	)
)

# shuffle all cards in the deck
(class_function world_game void shuffleDeck ()
	(group
	(for (def int i 0) (< i this.deckTotal) (= i (+ i 1))
		(group
		(def int target (dd_math_randPseudo this.deckTotal))
		(def ref Card temp)
		(= temp this.deck[i])
		(= this.deck[i] this.deck[target])
		(= this.deck[target] temp)

		(def dd_matrix mat)
		(dd_matrix_copy mat this.deckMatrix)
		(dd_matrix_translate mat 0 0 (+ (* -0.003 (+ i 1)) -0.01))
		(this.deck[i].setTarget mat)

		(dd_matrix_copy mat this.deckMatrix)
		(dd_matrix_translate mat 0 0 (+ (* -0.003 (+ target 1)) -0.01))
		(this.deck[target].setTarget mat)

		)
	)
	)
)

(class_function world_game void applyArrowRotation (group int playerIndex)
	(group
	(= this.arrowRotationTarget (- 0 (* (/ 360.0 this.playersTotal) playerIndex)))
	(if (< this.arrowRotation this.arrowRotationTarget)
		(group
		(= this.arrowRotation (+ this.arrowRotation 360))
		)
	)
	)
)

(class_function world_game void applyChooseCard (group int optionIndex)
	(group
	(if (== optionIndex 0)
		(this.setRosePlayer (% (+ this.rosePlayer 1) this.playersTotal))
		(this.setRosePlayer (% (+ this.rosePlayer 3) this.playersTotal))
	)
	)
)

(class_function world_game void addAction (group int actionType int playerIndex int valueAmount int delay)
	(group
	(if (>= this.actionsTotal 100)
		(group
		(echo "Max actions reached, cannot add more")
		)
	# else
		(group
		(this.actions[this.actionsTotal].set actionType playerIndex valueAmount delay)
		(= this.actionsTotal (+ this.actionsTotal 1))
		)
	)
	)
)

(class_function world_game void removeAction ()
	(group
	(if (<= this.actionsTotal 0)
		(group
		(echo "No actions to remove")
		)
		(group
		(for (def int i 1) (< i this.actionsTotal) (= i (+ i 1))
			(group
			(def int prevIndex (- i 1))
			(this.actions[prevIndex].set this.actions[i].actionType this.actions[i].playerIndex this.actions[i].value this.actions[i].delay)
			)
		)
		)
	)

	(= this.actionsTotal (- this.actionsTotal 1))
	)
)

(class_function world_game void addInjectAction (group int actionType int playerIndex int valueAmount int delay)
	(group
	(if (>= this.injectActionsTotal 100)
		(group
		(echo "Max inject actions reached, cannot add more")
		)
	# else
		(group
		(this.injectActions[this.injectActionsTotal].set actionType playerIndex valueAmount delay)
		(= this.injectActionsTotal (+ this.injectActionsTotal 1))
		)
	)
	)
)

(class_function world_game void injectActionsToActions ()
	(group
	(if (>= (+ this.injectActionsTotal this.actionsTotal) 100)
		(group
		(echo "Can't inject actions, too many")
		)
	# else
		(group

		# move all current actions towards the end of the array, to make room for injected ones
		# current action remains intact
		(for (def int i (- this.actionsTotal 1)) (> i 0) (= i (- i 1))
			(group
			(def int destIndex (+ i this.injectActionsTotal))
			(this.actions[destIndex].set
				this.actions[i].actionType
				this.actions[i].playerIndex
				this.actions[i].value
				this.actions[i].delay
			)
			)
		)

		# add injected actions in that space
		(for (def int i 0) (< i this.injectActionsTotal) (= i (+ i 1))
			(group
			(def int actIndex (+ i 1))
			(this.actions[actIndex].set
				this.injectActions[i].actionType
				this.injectActions[i].playerIndex
				this.injectActions[i].value
				this.injectActions[i].delay
			)
			)
		)

		# reset injected actions array
		(= this.actionsTotal (+ this.actionsTotal this.injectActionsTotal))
		(= this.injectActionsTotal 0)

		)
	)
	)
)

(class_function world_game void grabRose ()
	(group

	# rose is flat, grab it!
	(if this.isRoseFlat
		(group
		(= this.isRoseFlat 0)
		(this.player[this.rosePlayer].addCard this.roseCard)
		)
	)

	)
)

# game actions
(class_function GameAction void create ()
	(group
	(= this.actionType -1)
	(= this.playerIndex -1)
	(= this.value 0)
	)
)

(class_function GameAction void clean ()
	(group
	)
)

(class_function GameAction void set (group int actionType int playerIndex int valueAmount int delay)
	(group
	(= this.actionType actionType)
	(= this.playerIndex playerIndex)
	(= this.value valueAmount)
	(= this.delay delay)
	)
)

(class_function world_game void prepareDeckFull ()
	(group
	(= this.cardsTotal 53)
	# single steps
	(for (def int i 0) (< i 5) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_SINGLE_STEP)
		(= this.cards[i].mesh this.cardFront[CARD_SINGLE_STEP])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_SINGLE_STEP])
		)
	)

	# triple steps
	(for (def int i 5) (< i (+ 5 4)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_THREE_STEPS)
		(= this.cards[i].mesh this.cardFront[CARD_THREE_STEPS])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_THREE_STEPS])
		)
	)

	# trade
	(for (def int i 9) (< i (+ 9 3)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_TRADE)
		(= this.cards[i].mesh this.cardFront[CARD_TRADE])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_TRADE])
		)
	)
	(= this.cards[ 9].cornerId CARD_CORNER_TEAR)
	(= this.cards[10].cornerId CARD_CORNER_HEART)
	(= this.cards[11].cornerId CARD_CORNER_FROWN)
	(= this.cards[ 9].meshCorner this.cardCorner[CARD_CORNER_TEAR])
	(= this.cards[10].meshCorner this.cardCorner[CARD_CORNER_HEART])
	(= this.cards[11].meshCorner this.cardCorner[CARD_CORNER_FROWN])

	# conditional
	(for (def int i 12) (< i (+ 12 4)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_CONDITIONAL)
		(= this.cards[i].mesh this.cardFront[CARD_CONDITIONAL])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_CONDITIONAL])
		)
	)
	(= this.cards[12].cornerId CARD_CORNER_TEAR)
	(= this.cards[13].cornerId CARD_CORNER_FROWN)
	(= this.cards[14].cornerId CARD_CORNER_HEART)
	(= this.cards[12].meshCorner this.cardCorner[CARD_CORNER_TEAR])
	(= this.cards[13].meshCorner this.cardCorner[CARD_CORNER_FROWN])
	(= this.cards[14].meshCorner this.cardCorner[CARD_CORNER_HEART])

	# replace
	(for (def int i 16) (< i (+ 16 3)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_REPLACE)
		(= this.cards[i].mesh this.cardFront[CARD_REPLACE])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_REPLACE])
		)
	)
	(= this.cards[16].cornerId CARD_CORNER_TEAR)
	(= this.cards[17].cornerId CARD_CORNER_FROWN)
	(= this.cards[18].cornerId CARD_CORNER_HEART)
	(= this.cards[16].meshCorner this.cardCorner[CARD_CORNER_TEAR])
	(= this.cards[17].meshCorner this.cardCorner[CARD_CORNER_FROWN])
	(= this.cards[18].meshCorner this.cardCorner[CARD_CORNER_HEART])

	# grab
	(for (def int i 19) (< i (+ 19 4)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_GRAB)
		(= this.cards[i].mesh this.cardFront[CARD_GRAB])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_GRAB])
		)
	)
	(= this.cards[19].cornerId CARD_CORNER_TEAR)
	(= this.cards[20].cornerId CARD_CORNER_THUNDER)
	(= this.cards[21].cornerId CARD_CORNER_HEART)
	(= this.cards[19].meshCorner this.cardCorner[CARD_CORNER_TEAR])
	(= this.cards[20].meshCorner this.cardCorner[CARD_CORNER_THUNDER])
	(= this.cards[21].meshCorner this.cardCorner[CARD_CORNER_HEART])

	# grab gen
	(for (def int i 23) (< i (+ 23 4)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_GRAB_GENERIC)
		(= this.cards[i].mesh this.cardFront[CARD_GRAB_GENERIC])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_GRAB_GENERIC])
		)
	)
	(= this.cards[23].cornerId CARD_CORNER_FROWN)
	(= this.cards[24].cornerId CARD_CORNER_THUNDER)
	(= this.cards[25].cornerId CARD_CORNER_HEART)
	(= this.cards[23].meshCorner this.cardCorner[CARD_CORNER_FROWN])
	(= this.cards[24].meshCorner this.cardCorner[CARD_CORNER_THUNDER])
	(= this.cards[25].meshCorner this.cardCorner[CARD_CORNER_HEART])

	# approach
	(for (def int i 27) (< i (+ 27 3)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_APPROACH)
		(= this.cards[i].mesh this.cardFront[CARD_APPROACH])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_APPROACH])
		)
	)
	(= this.cards[27].cornerId CARD_CORNER_THUNDER)
	(= this.cards[28].cornerId CARD_CORNER_FROWN)
	(= this.cards[29].cornerId CARD_CORNER_TEAR)
	(= this.cards[27].meshCorner this.cardCorner[CARD_CORNER_THUNDER])
	(= this.cards[28].meshCorner this.cardCorner[CARD_CORNER_FROWN])
	(= this.cards[29].meshCorner this.cardCorner[CARD_CORNER_TEAR])

	# win
	(for (def int i 30) (< i (+ 30 5)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_WIN)
		(= this.cards[i].mesh this.cardFront[CARD_WIN])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_WIN])
		)
	)

	# hold one step
	(for (def int i 35) (< i (+ 35 5)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_HOLD_ONE_STEP)
		(= this.cards[i].mesh this.cardFront[13])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_HOLD_ONE_STEP])
		)
	)

	# next hand
	(for (def int i 40) (< i (+ 40 3)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_NEXT_HAND)
		(= this.cards[i].mesh this.cardFront[11])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_NEXT_HAND])
		)
	)
	(= this.cards[40].cornerId CARD_CORNER_TEAR)
	(= this.cards[41].cornerId CARD_CORNER_HEART)
	(= this.cards[42].cornerId CARD_CORNER_THUNDER)
	(= this.cards[40].meshCorner this.cardCorner[CARD_CORNER_TEAR])
	(= this.cards[41].meshCorner this.cardCorner[CARD_CORNER_HEART])
	(= this.cards[42].meshCorner this.cardCorner[CARD_CORNER_THUNDER])

	# ignore move
	(for (def int i 43) (< i (+ 43 3)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_IGNORE_MOVE)
		(= this.cards[i].mesh this.cardFront[10])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_IGNORE_MOVE])
		)
	)
	(= this.cards[43].cornerId CARD_CORNER_TEAR)
	(= this.cards[44].cornerId CARD_CORNER_THUNDER)
	(= this.cards[45].cornerId CARD_CORNER_FROWN)
	(= this.cards[43].meshCorner this.cardCorner[CARD_CORNER_TEAR])
	(= this.cards[44].meshCorner this.cardCorner[CARD_CORNER_THUNDER])
	(= this.cards[45].meshCorner this.cardCorner[CARD_CORNER_FROWN])

	# rose held
	(for (def int i 46) (< i (+ 46 3)) (= i (+ i 1))
		(group
		(this.cards[i].setId CARD_ROSE_HELD_STEAL)
		(= this.cards[i].mesh this.cardFront[14])
		(= this.cards[i].cardDescription2 this.cardLabel[CARD_ROSE_HELD_STEAL])
		)
	)
	(= this.cards[46].cornerId CARD_CORNER_THUNDER)
	(= this.cards[47].cornerId CARD_CORNER_FROWN)
	(= this.cards[48].cornerId CARD_CORNER_HEART)
	(= this.cards[46].meshCorner this.cardCorner[CARD_CORNER_THUNDER])
	(= this.cards[47].meshCorner this.cardCorner[CARD_CORNER_FROWN])
	(= this.cards[48].meshCorner this.cardCorner[CARD_CORNER_HEART])

	# empty
	(this.cards[49].setId CARD_EMPTY_TEAR)
	(= this.cards[49].mesh this.cardFront[12])
	(= this.cards[49].cardDescription2 this.cardLabel[CARD_EMPTY_TEAR])

	(this.cards[50].setId CARD_EMPTY_HEART)
	(= this.cards[50].mesh this.cardFront[12])
	(= this.cards[50].cardDescription2 this.cardLabel[CARD_EMPTY_HEART])

	(this.cards[51].setId CARD_EMPTY_THUNDER)
	(= this.cards[51].mesh this.cardFront[12])
	(= this.cards[51].cardDescription2 this.cardLabel[CARD_EMPTY_THUNDER])

	(this.cards[52].setId CARD_EMPTY_FROWN)
	(= this.cards[52].mesh this.cardFront[12])
	(= this.cards[52].cardDescription2 this.cardLabel[CARD_EMPTY_FROWN])

	)
)

(class_function world_game void confirmSelection ()
	(group
	# someone has won, move to next menu
	(if (>= this.victoriousPlayer 0)
		(group
		(this.saveLoad.CompleteGame)
		(dd_world_prepare world_menu 1.0)
		(dd_world_ready)
		)
	# nobody has won - proceed with input handling
		(group

		# showing overlay card
		(if this.ovButtons.cardToShow
			(group
			(if (this.ovButtons.click)
				(group
				# skip effect
				(if (&& (== this.actions[0].actionType ACTION_SELECT_CARD) (== this.ovButtons.waitUntilCardConfirmed 0))
					(group
					(= this.filterCorner -1)
					(= this.lastSelectedCardPlayerIndex -1)
					(= this.lastSelectedCardIndex -1)
					(= this.actions[0].actionType ACTION_DELAY)
					# multiplayer game, send move to other players
					(if isMultiplayerGame
						(group
	
						# prepare move
						(def MultiplayerMessageGameTurn msg)
						(= msg.playerIndex (% (+ (+ this.lastSelectedCardPlayerIndex this.playersTotal) networkOffsetindex) this.playersTotal))
						(= msg.cardIndex this.lastSelectedCardIndex)
	
						# send move to all other players
						(avdl_multiplayer_sendMessage 0 msg MultiplayerMessageGameTurn)
	
						)
					)
					)
				)
				)
			)
			)
		)

		# network user, wait for their input
		(if (== this.player[this.actions[0].playerIndex].type 10)
			(return)
		)

		# waiting user to select a card
		(if (&& (> this.actionsTotal 0) (== this.actions[0].actionType ACTION_SELECT_CARD) (== this.actions[0].playerIndex 0))
			(group

			# just selected a card
			(if (&& (== this.player[0].userLookingAtCard this.player[0].highlightCard)
				(>= this.player[0].highlightCard 0))
				(group

				(= this.lastSelectedCardPlayerIndex 0)
				(= this.lastSelectedCardIndex this.player[0].highlightCard)
				(= this.filterCorner -1)
				(this.ovButtons.unsetCard)
				(= this.actions[0].actionType ACTION_DELAY)
				(= this.actions[0].delay 0)

				(= this.player[0].userLookingAtCard -1)
				(= this.player[0].highlightCard -1)
				(= this.phaseTextCurrent this.phaseTextExecution)

				# multiplayer game, send move to other players
				(if isMultiplayerGame
					(group

					# prepare move
					(def MultiplayerMessageGameTurn msg)
					(= msg.playerIndex (% (+ (+ this.lastSelectedCardPlayerIndex this.playersTotal) networkOffsetindex) this.playersTotal))
					(= msg.cardIndex this.lastSelectedCardIndex)

					# send move to all other players
					(avdl_multiplayer_sendMessage 0 msg MultiplayerMessageGameTurn)

					)
				)

				)
			# just highlighted card
				(group
				(if (|| (== this.filterCorner -1) (&&
				(>= this.filterCorner 0) (>= this.player[0].userLookingAtCard 0)
				(== this.player[0].cards[this.player[0].userLookingAtCard].cornerId this.filterCorner)))
					(this.player[0].highlightLookingCard)
					(= this.player[0].highlightCard -1)
				)
				)
			)

			)
		# waiting network user to select a card
		(&& (> this.actionsTotal 0) (== this.actions[0].actionType ACTION_SELECT_CARD) (== this.player[this.actions[0].playerIndex].type 10) )
			(group)
		)

		)
	) # was waiting for user input
	)
)
