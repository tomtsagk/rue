(include "game.ddh")

(def extern ref dd_meshColour newCardMesh)
(def extern ref Card newCard)
(class_function world_game void create (group)
	(group

	# camera control
	(= this.rotX 0)
	(= this.rotY 0)
	(= this.targetRotX 0)
	(= this.targetRotY 0)
	(= this.holdRotX -1)
	(= this.holdRotY -1)

	# center of world
	(dd_matrix_identity this.matCenter)
	(dd_matrix_translate this.matCenter 0 -4 -5)

	# stage
	(this.stage.load (asset "assets/stage_1.asset" DD_PLY))
	(this.table.load (asset "assets/table_1.asset" DD_PLY))

	# card back
	(this.cardBack.load (asset "assets/card_border.asset" DD_PLY))
	(this.cardBack.loadTexture (asset "assets/card_border_texture.asset" DD_PLY))

	# card cardFront
	(this.cardFront[0].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[0].loadTexture (asset "assets/card_action_2.asset" DD_PLY))

	(this.cardFront[1].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[1].loadTexture (asset "assets/card_action_3.asset" DD_PLY))

	(this.cardFront[2].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[2].loadTexture (asset "assets/card_action_4.asset" DD_PLY))

	(this.cardFront[3].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[3].loadTexture (asset "assets/card_action_5.asset" DD_PLY))

	(this.cardFront[4].load (asset "assets/card.asset" DD_PLY))
	(this.cardFront[4].loadTexture (asset "assets/card_action_6.asset" DD_PLY))

	# cards
	(= this.cardsTotal 48)
	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(def int index (dd_math_rand 5))
		(= this.cards[i].mesh this.cardFront[index])
		(= this.cards[i].meshBack this.cardBack)
		(dd_matrix_identity this.cards[i])
		)
	)

	# deck
	(dd_matrix_identity this.deckMatrix)
	(dd_matrix_translate this.deckMatrix 0 2 0)
	(dd_matrix_rotate this.deckMatrix 90 1 0 0)
	(dd_matrix_scale this.deckMatrix 0.2 0.2 0.2)
	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(= this.deck[i] this.cards[i])
		(dd_matrix_mult this.cards[i].target this.deckMatrix)
		(dd_matrix_copy this.cards[i] this.cards[i].target)
		)
	)

	# players 3-8
	(= this.playersTotal 8)
	(= this.player[0].isUser 1)

	# init player positions
	(for (def int i 1) (< i this.playersTotal) (= i (+ i 1))
		(group
		(dd_matrix_identity this.player[i])
		(dd_matrix_rotate this.player[i] (+ 15 (* (/ 330.0 this.playersTotal) i)) 0 1 0)
		(dd_matrix_translate this.player[i] 0 0 5)

		(if (< i (/ this.playersTotal 2))
			(dd_matrix_rotate this.player[i] 10 0 1 0)
		(> i (/ this.playersTotal 2))
			(dd_matrix_rotate this.player[i] -10 0 1 0)
		)

		(dd_matrix_rotate this.player[i] 180 0 1 0)
		)
	)
	(dd_matrix_identity this.player[0])
	(dd_matrix_translate this.player[0] 0 0 5)
#	(for (def int i 0) (< i this.playersTotal) (= i (+ i 1))
#	(for (def int j 0) (< j 5) (= j (+ j 1))
#		(group
#		(def int index (+ (* i 5) j))
#		(this.player[i].addCard this.cards[index])
#		)
#	)
#	)

	(= this.rotating 0)

	)
)

(class_function world_game void onload (group)
	(group
	)
)

#(class_function world_game void resize (group)
#	(group
#	)
#)

(class_function world_game void update (group)
	(group

	(= this.rotating (+ this.rotating 1))

	# calculate new camera look at point
	(if (>= this.holdRotX 0)
		(group
		(= this.targetRotX (+ this.targetRotX (- (dd_mouse_x) this.holdRotX)))
		(= this.holdRotX (dd_mouse_x))

		(= this.targetRotY (- this.targetRotY (- (dd_mouse_y) this.holdRotY)))
		(= this.holdRotY (dd_mouse_y))
		)
	)

	# slowly approach camera look at point
	(= this.rotX (dd_math_ease_linear 0.1 this.rotX this.targetRotX))
	(= this.rotY (dd_math_ease_linear 0.1 this.rotY this.targetRotY))

	# update all cards to approach target
	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(dd_matrix_approach this.cards[i] this.cards[i].target 0.1)
		)
	)

	)
) # update

(class_function world_game void draw (group)
	(group

	# camera
	(dd_rotatef this.rotY -1 0 0)
	(dd_rotatef this.rotX 0 1 0)

	# center of world
	(dd_multMatrixf this.matCenter)

	# stage
	(this.stage.draw)
	(this.table.draw)

	# draw deck
	(dd_matrix_push)
	#(dd_multMatrixf this.deckMatrix)
	(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
		(group
		(if this.deck[i]
			(this.deck[i].draw)
		)
		)
	)
	(dd_matrix_pop)

	# draw every player apart from self
	(for (def int i 1) (< i this.playersTotal) (= i (+ i 1))
		(group
		(dd_matrix_push)
		(this.player[i].draw)
		(dd_matrix_pop)
		)
	)

	# draw player
	(dd_matrix_push)
	#(dd_translatef 0 0 5)
	(this.player[0].draw)
	(dd_matrix_pop)

	# rotating card
#	(dd_translatef 0 3.5 0)
#	(dd_rotatef this.rotating 0 1 0)
#	(dd_scalef 0.5 0.5 0.5)
#	(this.cardBack.draw)
#	(this.cardFront[1].draw)

	)
)

(class_function world_game void key_input (group char key)
	(group
	(if (== key 27)
		(= dd_flag_exit 1) # exit game
	# test 'd' give random card to random player
	(== key 100)
		(group
		(for (def int i 0) (< i this.cardsTotal) (= i (+ i 1))
			(group
			(if this.deck[i]
				(group
				(def int index (dd_math_rand this.playersTotal))
				(this.player[index].addCard this.deck[i])
				(= this.deck[i] 0)
				(= i 100)
				)
			)
			)
		)
		) # 'd' button
	) # key input
	)
)

(class_function world_game void clean (group)
	(group
	)
)

(class_function world_game void mouse_input (group int button int type)
	(group

	# control the camera look at point when click and dragging
	(if (== type DD_INPUT_MOUSE_TYPE_PRESSED)
		(group
		(= this.holdRotX (dd_mouse_x))
		(= this.holdRotY (dd_mouse_y))
		)
	(== type DD_INPUT_MOUSE_TYPE_RELEASED)
		(group
		(= this.holdRotX -1)
		(= this.holdRotY -1)
		)
	)

	)
) # mouse input
